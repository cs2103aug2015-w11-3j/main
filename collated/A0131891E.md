# A0131891E
###### src\common\Configuration.java
``` java
    @Override
    /*
     * @see common.ConfigurationInterface#isUserAlias(java.lang.String)
     */
    public boolean isUserAlias(String alias) {
    	return configUserCmdAliases.containsKey(alias);
    }
    
    @Override
    /*
     * @see common.ConfigurationInterface#getUserAliasTargetName(java.lang.String)
     */
    public String getUserAliasTargetName(String alias) {
    	return configUserCmdAliases.get(alias);
    }
    
    // Setters
```
###### src\common\Configuration.java
``` java
    @Override
    /*
     * @see common.ConfigurationInterface#setUserAlias(java.lang.String, java.lang.String)
     */
    public void setUserAlias(String alias, String targetName) {
    	assert( alias != null 
    			&& targetName != null 
    			&& !alias.equals("")
    			&& !targetName.equals("")
    			);
    	
    	configUserCmdAliases.put(alias, targetName);
    	
    	writeBack();
    	Log.log("New alias mapping added: " + alias + "-->" + targetName, this.getClass());
    }
    
    @Override
    /*
     * @see common.ConfigurationInterface#removeUserAlias(java.lang.String)
     */
    public void removeUserAlias(String alias) {
    	assert(alias != null && alias.length() != 0);
    	configUserCmdAliases.remove(alias);
    	
    	writeBack();
    	Log.log("Alias mapping removed: " + alias, this.getClass());
    }
    
    // Resetters, used to reset certain properties to its/their default value
```
###### src\common\Configuration.java
``` java
    @Override
	public void clearUserAliases() {
    	configUserCmdAliases = new LinkedHashMap<String, String>();
    	writeBack();
    	Log.log("All user alias mappings cleared", this.getClass());
    }
	
	// Alias validation
    @SuppressWarnings("rawtypes")
	private boolean isValidAliasMap(Map aliasMap) {
		if (aliasMap == null) {
			return false;
		}
		@SuppressWarnings("unchecked")
		final Set<Map.Entry> entries = aliasMap.entrySet();
		
		// check each entry
		for (Map.Entry entry : entries) {
			
			if ( !(entry.getKey() instanceof String) || !(entry.getValue() instanceof String) ) {
				return false; // keys and vals must be Strings
			}
			
			if ( entry.getKey().equals("") || entry.getValue().equals("") ) {
				return false; // should have no empty string as key or value
			}
			
			// check target command
			try {
				CommandData.Type target = Enum.valueOf(CommandData.Type.class, (String) entry.getValue());
				if (target == CommandData.Type.INVALID) {
					return false; // cannot map to invalid command
				}
			} catch (IllegalArgumentException iae) {
				return false; // value not a valid Command.Type enum value
			}
			
			// check alias
			ALIASES = AliasesImpl.getInstance();
			if (ALIASES.isReservedCmdAlias((String)entry.getKey())) {
				return false; // reserved alias names cannot be redirected
			}
		}
	
		return true; // all tests passed, phew!
	}
	
    // Validators
```
###### src\common\Task.java
``` java
    // getters
    public boolean isCompleted() {
        return cIsCompleted.get();
    }

    public int getId() {
        return cId;
    }

    public String getName() {
        return cName.get();
    }

    public Date getStart() {
        if (cStart.get() == null) {
            return null;
        } else {
            return (Date) cStart.get().clone();
        }
    }

    public Date getEnd() {
        if (cEnd.get() == null) {
            return null;
        } else {
            return (Date) cEnd.get().clone();
        }
    }

    public Type getType() {
        return cType.get();
    }

    // get properties
    public StringProperty nameProperty() {
        return cName;
    }

    public ObjectProperty<Date> startProperty() {
        return cStart;
    }

    public ObjectProperty<Date> endProperty() {
        return cEnd;
    }

    public ObjectProperty<Type> typeProperty() {
        updateType();
        return cType;
    }

    public BooleanProperty isCompletedProperty() {
        return cIsCompleted;
    }

    public boolean isImportant() {
        return cIsImportant;
    }

    public void setImportant(Boolean impt) {
        this.cIsImportant = impt;
    }

```
###### src\common\Utilities.java
``` java
    /**
     * Simple check for whether (T[]) array contains (T) key
     */
    public static final <T> boolean arrayContains(T[] arr, T key) {
        assert (arr != null && key != null);
        return !Arrays.stream(arr).noneMatch((T x) -> key.equals(x));
    }

```
###### src\common\Utilities.java
``` java
    /**
     * Returns a deep copy of its argument
     * 
     * @param matrix
     * @return deep copy of matrix
     */
    public static final String[][] str2dArrayClone(String[][] matrix) {
        assert (matrix != null);
        final String[][] newMatrix = new String[matrix.length][];
        for (int i = 0; i < newMatrix.length; i++) {
            newMatrix[i] = Arrays.copyOf(matrix[i], matrix[i].length);
        }
        return newMatrix;
    }
    
```
###### src\logic\AliasAction.java
``` java
package logic;

import java.io.IOException;
import java.util.regex.Pattern;

import common.Log;
import common.TasksBag;
import common.Utilities;
import logic.exceptions.LogicException;
import parser.Aliases;
import parser.AliasesImpl;
import parser.commands.CommandData;

public class AliasAction implements Action {

	private static final String USR_MSG_CONFIG_ERROR = "Config saving error: your changes may not persist.";
    private static final String USR_MSG_ALIAS_CLEAR = "All custom alias mappings cleared";
	private static final String USR_MSG_ALIAS_RESERVED = "You cannot use the reserved keyword \"%s\" as an alias. Reserved keywords are shown in \"help\"";
	private static final String USR_MSG_ALIAS_SUCCESS = "Alias mapping created: %s --> %s";
	
	private static final Pattern P_VALID_ALIAS = Pattern.compile("^[\\S&&[^\\p{javaUpperCase}]]++$");
	
	private static final Aliases ALIASES = AliasesImpl.getInstance();
	
    private CommandData cCommand;
    private TasksBag cBag;
    
    private String newAlias;
    private CommandData.Type aliasTarget;
    
	public AliasAction(CommandData cmd, TasksBag internalBag) {
        cCommand = cmd;
        cBag = internalBag;
        newAlias = cmd.getText();
        aliasTarget = cmd.getSecondaryCmdType();
	}

	@Override
	public Feedback execute() throws LogicException {
		
		// user wants to clear alias mappings
		if (aliasTarget == null) { 
			try {
				ALIASES.clearCustomAliases();
			} catch (IOException ioe) {
				Log.log(ioe.toString());
				ioe.printStackTrace();
				throw new LogicException(USR_MSG_CONFIG_ERROR);
			}
			return new CommandFeedback(cCommand, cBag, USR_MSG_ALIAS_CLEAR);
		}
		
		assert newAlias != null // if aliasTarget != null, must have newAlias.
				&& !"".equals(newAlias) // parser won't parse empty string as alias
				&& aliasTarget != CommandData.Type.INVALID // parser shouldnt give INVALID
				&& P_VALID_ALIAS.matcher(newAlias).matches(); // parser should have removed whitespace and tolowercase
		
		// Don't allow user to user to re-map reserved keywords
		if (ALIASES.isReservedCmdAlias(newAlias)) {
			return new CommandFeedback(cCommand, cBag, Utilities.formatString(USR_MSG_ALIAS_RESERVED, newAlias));
		}
		
		// Add new alias mapping and save to config file
		try {
			ALIASES.setCustomAlias(newAlias, aliasTarget);
		} catch (IOException ioe) {
			Log.log(ioe.toString());
			ioe.printStackTrace();
			throw new LogicException(USR_MSG_CONFIG_ERROR);
		}
		return new CommandFeedback(cCommand, cBag, Utilities.formatString(USR_MSG_ALIAS_SUCCESS, newAlias, aliasTarget));
    }

}
```
###### src\logic\exceptions\IllegalAliasException.java
``` java
package logic.exceptions;

public class IllegalAliasException extends ActionException {

    private static final long serialVersionUID = -4790839133780670757L;

    public IllegalAliasException(String msg) {
        super(msg);
    }

}
```
###### src\parser\Aliases.java
``` java
package parser;

import java.io.IOException;

import parser.commands.CommandData;

/**
 * Handles all alias mapping and storage
 * 
 */
public abstract class Aliases {

	/////////////////////////////////////////////////////
	// Methods for command tokens
	/////////////////////////////////////////////////////
	
	public boolean isCmdAlias (String alias) {
		return isCustomAlias(alias) || isDefaultAlias(alias);
	};
	public abstract boolean isCustomAlias (String alias);
	public abstract boolean isDefaultAlias (String alias);
	public abstract boolean isReservedCmdAlias (String alias);
	
	public abstract CommandData.Type getCmdFromAlias (String alias);
	
	public abstract void setCustomAlias (String alias, CommandData.Type target) throws IOException;
	public abstract void clearCustomAliases () throws IOException;
	
	
	/////////////////////////////////////////////////////
	// Aliases for command tokens
	/////////////////////////////////////////////////////
	
	// cannot be used as alias (reserved)
	// make sure to update for new commands
	static final String[] CMD_RESERVED = {
		"add",
		"edit",
		"delete",
		
		"show",
		
		"mark",
		"unmark",
		
		"undo",
		"redo",
		
		"search",
		"filter",
		"clear",
		
		"skin",
		"help",
		"exit",
		"move"
	};
	
	static final String[] CMD_ADD = {
		"a",
		"add",
		"new",
		"create"
	};
	static final String[] CMD_UPD = {
		"upd",
		"update",
		"set",
		"edit"
	};
	static final String[] CMD_DEL = {
		"d",
		"del",
		"delete",
		"rm",
		"remove"
	};
	static final String[] CMD_MARK = {
		"done",
		"finish",
		"mark",
		"complete"
	};
	static final String[] CMD_UNMARK = {
		"unmark",
		"reopen",
		"uncomplete"
	};
	static final String[] CMD_UNDO = {
		"u",
		"un",
		"undo"
	};
	static final String[] CMD_REDO = {
		"redo",
		"re" 
	};
	static final String[] CMD_SHOW = {
		"show",
		"view",
		"display"
	};
	static final String[] CMD_SEARCH = {
		"s",
		"find",
		"search"
	};
	static final String[] CMD_FILTER = {
		"f",
		"fil",
		"filter"
	};
	static final String[] CMD_CLEAR = {
		"clr",
		"cls",
		"clear",
		"reset"
	};
	static final String[] CMD_MOVE = {
		"mv",
		"move"
	};
	static final String[] CMD_ALIAS = {
		"map",
		"alias",
		"shortcut",
		"point",
	};
	static final String[] CMD_HELP = {
		"help",
		"?",
		"-h"
	};
	static final String[] CMD_THEME = {
		"skin",
		"theme",
		"color",
		"colour"
	};
	static final String[] CMD_QUIT = {
		"q",	
		"quit",
		"exit"
	};
	
	/////////////////////////////////////////////////////
	// Aliases for Task field tokens
	/////////////////////////////////////////////////////
	static final String[] FIELD_NAME = {
		"name",
		"title",
		"text",
		"descr",
		"description"
	};
	static final String[] FIELD_START_DATE = {
		"at",
		"start",
		"starting",
		"from",
		"begin",
		"on"
	};
	static final String[] FIELD_END_DATE = {
		"by",
		"finish",
		"to",
		"end",
		"due",
		"till",
		"until"
	};

	/////////////////////////////////////////////////////
	// Aliases for show command arguments
	/////////////////////////////////////////////////////
	static final String[] VIEW_DEFAULT = {
		"",
		"urgent",
		"default",
		"upcoming"
	};
	static final String[] VIEW_INCOMPLETE = {
		"undone",
		"open",
		"incomplete",
		"unfinished",
		"pending"
	};
	static final String[] VIEW_COMPLETED = {
		"done",
		"closed",
		"complete",
		"completed",
		"finished"
	};
	
	/////////////////////////////////////////////////////
	// Aliases for filter command delimiters
	/////////////////////////////////////////////////////
	static final String[] FILTER_ARG_BEF = {
		"by",
		"bef",
		"before"
	};
	static final String[] FILTER_ARG_AFT = {
		"aft",
		"after"
	};
	static final String[] FILTER_ARG_BTW_START = {
		"from",
		"start",
		"b/w",
		"btw",
		"between",
		"range",
		"within"
	};
	static final String[] FILTER_ARG_BTW_END = {
		"by",
		"to",
		"end",
		"and",
		"till",
		"until"
	};

    /////////////////////////////////////////////////////
    // Aliases for themes
    /////////////////////////////////////////////////////
	static final String[] THEME_DAY = {
        "day",
        "light",
        "bright",
        "white"
	};
	static final String[] THEME_NIGHT = {
        "night",
        "shadow",
        "dark",
        "black"
	};
	
    /////////////////////////////////////////////////////////
    // Aliases for special update date values to remove date
    /////////////////////////////////////////////////////////
	// for UPDATE cmd removing of dates (task conversion event->deadline->float}
	static final String[] CLEAR_VAL = {
		"nil",
		"null",
		"none",
		"remove",
		"clear",
		"empty",
		"reset"
	};
	
}
```
###### src\parser\AliasesImpl.java
``` java
package parser;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import common.Configuration;
import parser.commands.CommandData;


public class AliasesImpl extends Aliases {

	private static AliasesImpl instance = null;
	public static Aliases getInstance () {
	    
		if (instance == null) {
		
		    instance = new AliasesImpl();
		}
		return instance;
	}
	
	// Stores the default alias->command.type mapping
	private final Map<String, CommandData.Type> DEFAULT_CMD_ALIASES;
	private final Set<String> RESERVED_CMD_ALIASES;
	
	private AliasesImpl () {
		DEFAULT_CMD_ALIASES = new LinkedHashMap<>();
		mapCmdTypeAliases();
		RESERVED_CMD_ALIASES = new LinkedHashSet<>(Arrays.asList(CMD_RESERVED));
	}
	
	private void mapCmdTypeAliases () {
		mapAliases(CMD_ADD, CommandData.Type.ADD);
		mapAliases(CMD_UPD, CommandData.Type.UPDATE);
		mapAliases(CMD_DEL, CommandData.Type.DELETE);
		
		mapAliases(CMD_MARK, CommandData.Type.MARK);
		mapAliases(CMD_UNMARK, CommandData.Type.UNMARK);
		
		mapAliases(CMD_UNDO, CommandData.Type.UNDO);
		mapAliases(CMD_REDO, CommandData.Type.REDO);
		
		mapAliases(CMD_SHOW, CommandData.Type.SHOW);
		
		mapAliases(CMD_SEARCH, CommandData.Type.SEARCH);
		mapAliases(CMD_FILTER, CommandData.Type.FILTER_DATE);
		mapAliases(CMD_CLEAR, CommandData.Type.CLEAR_FILTERS);
		
		mapAliases(CMD_MOVE, CommandData.Type.MOVE);
		mapAliases(CMD_ALIAS, CommandData.Type.ALIAS);
		
		mapAliases(CMD_HELP, CommandData.Type.HELP);
		mapAliases(CMD_THEME, CommandData.Type.THEME);
		
		mapAliases(CMD_QUIT, CommandData.Type.QUIT);
	}
	
	private void mapAliases (String[] aliases, CommandData.Type cmdType) {
		mapAliasesToValue(DEFAULT_CMD_ALIASES, cmdType, Arrays.asList(aliases));
	}
	
	/**
	 * Maps every key in keys to value, inside map.
	 * If any duplicate is detected in the map, assertion kills program.
	 * Since this is used only for alias mapping, any detected duplicates
	 * imply an error on the dev's part in specifying the aliases above.
	 * @param map : mappings are stored here.
	 * @param value : to be mapped by all aliases
	 * @param aliases : to be mapped to value
	 */
	private static final <V> void mapAliasesToValue (Map<String, V> map, V value, Collection<String> aliases) {
		assert(map != null && aliases != null && value != null);
		for (String alias : aliases) {
		    V var = map.put(alias, value);
			assert var == null : "duplicate key binding " + alias ; // no duplicates allowed
		}
	}

	// abstract class / interface methods
	
	@Override
	public boolean isCustomAlias (String alias) {
		assert(validAliasFormat(alias));
		alias = ParserControllerImpl.cleanText(alias);
		return Configuration.getInstance().isUserAlias(alias);
	}
	@Override
	public boolean isDefaultAlias (String alias) {
		assert(validAliasFormat(alias));
		alias = ParserControllerImpl.cleanText(alias);
		return DEFAULT_CMD_ALIASES.containsKey(alias);
	}
	@Override
	public boolean isReservedCmdAlias (String alias) {
		assert(validAliasFormat(alias));
		alias = ParserControllerImpl.cleanText(alias);
		return RESERVED_CMD_ALIASES.contains(alias);
	}
	
	@Override
	public CommandData.Type getCmdFromAlias (String alias) {
		assert(validAliasFormat(alias));
		alias = ParserControllerImpl.cleanText(alias);
		
		final String cmdName = Configuration.getInstance().getUserAliasTargetName(alias);
		CommandData.Type rtnCmd;
		
		// check custom user aliases first
		try { 
			// includes additional redundant check to make sure reserved aliases aren't overwritten
			if (cmdName != null && !RESERVED_CMD_ALIASES.contains(alias)) {
				rtnCmd = Enum.valueOf(CommandData.Type.class, cmdName);
				assert(rtnCmd != CommandData.Type.INVALID);
				return rtnCmd;
			}
		} catch (IllegalArgumentException iae) {
			;
		}
		// check default aliases now.
		rtnCmd = DEFAULT_CMD_ALIASES.get(alias);
		return rtnCmd;
	}
	
	@Override
	public void setCustomAlias (String alias, CommandData.Type target) throws IOException {
		assert(validAliasFormat(alias) && target != null && target != CommandData.Type.INVALID);
		alias = ParserControllerImpl.cleanText(alias);
		Configuration.getInstance().setUserAlias(alias, target.name());
	}
	@Override
	public void clearCustomAliases () throws IOException {
		Configuration.getInstance().clearUserAliases();
	}
	
	private static boolean validAliasFormat (String testee) {
		// not null and no whitespace
		return testee != null && testee.matches("\\S*+");
	}
}
```
###### src\parser\commands\Command.java
``` java
package parser.commands;

public abstract class Command implements CommandDataParser {

	final String INPUT;
	CommandData commandData;
	
	public Command(String input) {
		INPUT = input;
	}

}
```
###### src\parser\commands\CommandData.java
``` java
package parser.commands;

import java.nio.file.Path;
import java.util.Date;

import common.Task;
import common.TasksBag;
import ui.view.CelebiViewController.Skin;

/**
 * Base abstract class for the command datatype object.
 * Will be returned to Logic as result of parseCommand(String)
 * 
 * Only full user input string and command type are stored here (immutable)
 * Other fields have to be implemented by subclasses.
 * Their setters and getters have to be implemented as well.
 *
 * This allows developers to easily swap in/out any setting/getting
 * logic like validation, protection (clone object when getting) etc...
 * 
 * Subclasses also have the choice of storing their fields differently
 * Eg: Start and end dates can be implemented as a calendar,
 * Text as a suffix tree etc.
 * As long as it is converted back into String/Date/whatever as per
 * the getter contracts here.
 */
public abstract class CommandData {

	// Uniquely identifies which Action to create in Logic
	public static enum Type {
		ADD, DELETE, UPDATE, 
		SHOW,
		SEARCH, FILTER_DATE, CLEAR_FILTERS,
		UNDO, REDO,
		MARK, UNMARK,
		QUIT, 
		MOVE, HELP, 
		ALIAS, THEME,
		INVALID
	}
	
	private final String _userInput;
	private final Type _cmdType;
	
	CommandData (Type type, String rawInput) {
		_userInput = rawInput;
		_cmdType = type;
	}
	
	
	/** INVALID
	 * Provides user's raw input string for if input string cannot be parsed into recognised command type
	 * @return String
	 */
	public final String getRawUserInput () {
		return _userInput;
	}
	
	
	///////////////////////////////////////////////////
	// Identifiers (bounded discrete values)
	///////////////////////////////////////////////////
	
	/** ALL
	 * Identifies the type of command for further processing
	 * @return Command.Type (enum), null if NA
	 */
	public Type getCmdType () {
		return _cmdType;
	}
	
	/** DELETE, UPDATE, MARK, UNMARK
	 * Identifies a specific Celebi task object by index on UI for further processing.
	 * Uses the index as shown on the UI to the user, Logic must perform UID->real ID mapping.
	 * @return int, -1 if not applicable
	 */
	public abstract int getTaskUID ();
	public abstract void setTaskUID (int uid);
	
	/** UPDATE
	 * Identifies a specific field type within the Celebi object for field-level processing.
	 * @return Task.DataType (enum), null if NA
	 */
	public abstract Task.DataType getTaskField ();
	public abstract void setTaskField (Task.DataType field);
	
	/** HELP, ALIAS
	 * Identifies a command type for command type specific operations
	 * Will be null if the user is requesting the general help (to list all cmds)
	 * @return Command.Type (enum), or null if general help requested
	 */
	public abstract Type getSecondaryCmdType ();
	public abstract void setSecondaryCmdType (Type type);
	
	/** SHOW
	 * Identifies which of the 3 view tabs the user wishes to switch to.
	 * @return TasksBag.ViewType for setting view
	 */
	public abstract TasksBag.ViewType getViewType ();
	public abstract void setViewType (TasksBag.ViewType tab);
	
	/** THEME
	 * Identifies which theme the user wishes to switch to
	 * @return CelebiViewController.Skin
	 */
	public abstract Skin getTheme ();
	public abstract void setTheme (Skin theme);
	
	
	///////////////////////////////////////////////////////////////////
	// User defined data values (unbounded values)
	//
	// NULL values will be returned if those fields are not applicable.
	// Advisable for implementations to protect inner fields from mutation.
	///////////////////////////////////////////////////////////////////
	
	/** ADD, UPDATE, SEARCH, ALIAS
	 * Each of the above potentially need a string to work with
	 * @return String names or search strings or new alias
	 */
	public abstract String getText ();
	public abstract void setText (String text);
	
	/** ADD, UPDATE, FILTER
	 * Each of the above potentially need a start date to work with	
	 * @return Date for starting in filter range or task
	 */
	public abstract Date getStart ();
	public abstract void setStart (Date start);
	//abstract void setStart (Calendar start);
	
	/** ADD, UPDATE, FILTER
	 * Each of the above potentially need an end date to work with	
	 * @return Date for ending in filter range or task
	 */
	public abstract Date getEnd ();
	public abstract void setEnd (Date end);
	
	/** MOVE
	 * @return Path to shift task file to
	 */
	public abstract Path getPath ();
	public abstract void setPath (Path p);
	
}
```
###### src\parser\commands\CommandDataImpl.java
``` java
package parser.commands;

import java.nio.file.Path;
import java.util.Date;
import common.Task;
import common.TasksBag;
import ui.view.CelebiViewController;

public class CommandDataImpl extends CommandData {
	
	// identifiers
	private int _taskUID;
	private Task.DataType _taskField;
	private CommandData.Type _secondaryCmdType;
	private TasksBag.ViewType _viewType;
	private CelebiViewController.Skin _theme;
	
	// field values
	private String _name;
	private Date _startDate, _endDate;
	private Path _path;

	////////////////////////////////////////////////////////////////////////////////////	
	// Constructor (package private)
	////////////////////////////////////////////////////////////////////////////////////
	public CommandDataImpl (CommandData.Type cmd, String userInput) {
		super(cmd, userInput);
		_taskUID = -1;
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	// SETTERS 
	////////////////////////////////////////////////////////////////////////////////////
	
	// Identifiers 
	
	@Override
	public 
	void setTaskUID (int uid) {
		_taskUID = uid;
	}
	@Override
	public 
	void setTaskField (Task.DataType f) {
		_taskField = f;
	}
	@Override
	public 
	void setViewType (TasksBag.ViewType v) {
		_viewType = v;
	}
	@Override
	public 
	void setSecondaryCmdType (CommandData.Type t) {
		assert(t != CommandData.Type.INVALID);
		_secondaryCmdType = t;
	}
	@Override
	public 
	void setTheme (CelebiViewController.Skin theme) {
		_theme = theme;
	}
	
	// Data
	
	@Override
	public 
	void setText (String name) {
		_name = name;
	}
	@Override
	public 
	void setStart (Date d) {
		_startDate = d == null ? null : (Date) d.clone();
	}
	@Override
	public 
	void setEnd (Date d) {
		_endDate = d == null ? null : (Date) d.clone();
	}
	@Override
	public 
	void setPath (Path p) {
		_path = p;
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	// GETTERS
	////////////////////////////////////////////////////////////////////////////////////

	// Identifiers

	@Override
	public CommandData.Type getSecondaryCmdType() {
		return _secondaryCmdType;
	}
	@Override
	public int getTaskUID () {
		return _taskUID;
	}
	@Override
	public Task.DataType getTaskField () {
		return _taskField;
	}
	@Override
	public TasksBag.ViewType getViewType () {
		return _viewType;
	}
	@Override
	public CelebiViewController.Skin getTheme () {
		return _theme;
	}
	
	// User data values

	@Override
	public String getText () {
		return _name;
	}
	@Override
	public Date getStart () {
		return _startDate == null ? null : (Date)_startDate.clone();
	}
	@Override
	public Date getEnd () {
		return _endDate == null ? null : (Date)_endDate.clone();
	}
	@Override
	public Path getPath() {
		return _path;
	}
}
```
###### src\parser\commands\CommandDataParser.java
``` java
package parser.commands;

public interface CommandDataParser {
	public CommandData parseCommandData(String input);
}
```
###### src\parser\HelpStrings.java
``` java
package parser;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import common.Utilities;
import parser.commands.CommandData;

public final class HelpStrings {
	
    /////////////////////////////////////////////////////////////////
    // Human-readable strings for command formats (used by logic.HelpAction and UI popup)
    /////////////////////////////////////////////////////////////////
	
    public static final String HELP_LIST_ALL_CMDS = "ALL CMDS: add, delete, edit, mark, unmark, show, undo, redo, search, filter, clear, alias, move, skin, help, exit ";

    public static final String FORMAT_ADD = "Add New: [ %1$s \"name\" ]   [ %1$s \"name\"; due|start \"date\" ]   [ %1$s \"name\"; from \"start date\" to \"end date\" ]";
    public static final String FORMAT_DELETE = "Deleting Task: [ delete \"task ID number\" ]";
    public static final String FORMAT_UPDATE = "Editing Task: [ %1$s \"task ID number\" name|start|end \"new value\" ]";
    
    public static final String FORMAT_MARK = "Marking as Completed: [ %1$s \"task ID number\" ]";
    public static final String FORMAT_UNMARK = "Marking as Incomplete: [ %1$s \"task ID number\" ]";
    
    public static final String FORMAT_SHOW = "Changing View Tab: [ %1$s default ]   [ %1$s done ]   [ %1$s unfinished ]";
    
    public static final String FORMAT_UNDO = "Undo Previous Changes To Tasks: [ %1$s ]";
    public static final String FORMAT_REDO = "Redo Previously Undone Action: [ %1$s ]";
    
    public static final String FORMAT_SEARCH = "Searching in Names: [ %1$s \"words to find in task names\" ]";
    public static final String FORMAT_FILTER = "Filter by Date: [ %1$s before|after \"reference date\" ] OR [ %1$s within \"earliest\" and \"latest\" ]";
    public static final String FORMAT_MOVE = "Change Save File Location: [ %1$s \"new save file path\" ]";
    public static final String FORMAT_CLEAR = "Clear Current Search/Filters: [ %1$s ]";
    
    public static final String FORMAT_ALIAS = "Set Alias for Command: [ %1$s \"target command\" \"new alias\" ]   [ %1$s reset ]";
    public static final String FORMAT_THEME = "Change Colour Theme: [ %1$s day|night ]";
    
    public static final String FORMAT_QUIT = "Quit Celebi :( [ %1$s ]";
    public static final String FORMAT_HELP = "Get Help! [ %1$s ] ";
    
    
    private static final Pattern P_NO_WHITESPACE = Pattern.compile("\\S*+");
    
    private static final Aliases ALIASES = AliasesImpl.getInstance();
    
    private static final Map<CommandData.Type, String> CMD_FORMATS = mapCmdToFormatStrings();

    public static String getHelpToolTip(String token){
    	assert(token != null && P_NO_WHITESPACE.matcher(token).matches());

    	CommandData.Type cmdType = ALIASES.getCmdFromAlias(ParserControllerImpl.cleanText(token));
    	assert(cmdType != CommandData.Type.INVALID);
    	
    	if (cmdType == null) {
    		return null; // cannot parse as command token
    	}
    	
    	final String formatStr = CMD_FORMATS.get(cmdType);
    	return Utilities.formatString(formatStr, token);    	
    }
    
    private static Map<CommandData.Type, String> mapCmdToFormatStrings () {
    	final Map<CommandData.Type, String> map = new HashMap<>();
    	
    	map.put( CommandData.Type.ADD, FORMAT_ADD );
    	map.put( CommandData.Type.DELETE, FORMAT_DELETE );
    	map.put( CommandData.Type.UPDATE, FORMAT_UPDATE );
    	
    	map.put( CommandData.Type.MARK, FORMAT_MARK );
    	map.put( CommandData.Type.UNMARK, FORMAT_UNMARK );
    	
    	map.put( CommandData.Type.SHOW, FORMAT_SHOW );
    	
    	map.put( CommandData.Type.UNDO, FORMAT_UNDO );
    	map.put( CommandData.Type.REDO, FORMAT_REDO );
    	
    	map.put( CommandData.Type.SEARCH, FORMAT_SEARCH );
    	map.put( CommandData.Type.FILTER_DATE, FORMAT_FILTER );
    	map.put( CommandData.Type.CLEAR_FILTERS, FORMAT_CLEAR );
    	
    	map.put( CommandData.Type.ALIAS, FORMAT_ALIAS );
    	map.put( CommandData.Type.THEME, FORMAT_THEME );
    	map.put( CommandData.Type.QUIT, FORMAT_QUIT );
    	map.put( CommandData.Type.HELP, FORMAT_HELP );
    	map.put( CommandData.Type.MOVE, FORMAT_MOVE );
    	
    	return map;
    }
 
}
```
###### src\parser\ParserController.java
``` java
package parser;

import java.nio.file.Path;
import java.util.Date;
import parser.commands.CommandDataParser;

import static ui.view.CelebiViewController.Skin;
import common.TasksBag;
import parser.commands.CommandData;

public interface ParserController extends CommandDataParser {
	
	// Used in actual program execution flow
	public void init();
	
	// Manually create commands for logic testing.
	public CommandData makeAdd (String name, Date start, Date end);
	public CommandData makeUpdateName (int taskUID, String newName);
	public CommandData makeUpdateStart (int taskUID, Date newDate);
	public CommandData makeUpdateEnd (int taskUID, Date newDate);
	public CommandData makeDelete (int taskUID);
	public CommandData makeQuit ();
	public CommandData makeInvalid ();
	public CommandData makeShow (TasksBag.ViewType viewType);
	public CommandData makeRedo ();
	public CommandData makeUndo ();
	public CommandData makeMark (int taskUID);
	public CommandData makeUnmark (int taskUID);
	public CommandData makeSearch (String searchKey);
	public CommandData makeFilterDate (Date rangeStart, Date rangeEnd);
	public CommandData makeClear ();
	public CommandData makeMove (Path newPath);
	public CommandData makeHelp (CommandData.Type helpTarget);
	public CommandData makeTheme (Skin theme);
	public CommandData makeAlias (String alias, CommandData.Type target);
	
	// to debug command
	public static void printCmd (CommandData c) {
		System.out.println("type: " + c.getCmdType());
		System.out.println("raw: " + c.getRawUserInput());
		System.out.println("uid: " + c.getTaskUID());
		System.out.println("fieldkey: " + c.getTaskField());
		System.out.println("name: " + c.getText());
		System.out.println("start: " + c.getStart());
		System.out.println("end: "+ c.getEnd());
	}
}
```
###### src\parser\ParserControllerImpl.java
``` java
package parser;

import static java.util.regex.Pattern.CASE_INSENSITIVE;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.ParseException;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

//import com.sun.javafx.css.Combinator;
import common.Task;
import common.TasksBag;
import common.Utilities;
import parser.commands.CommandData;
import parser.commands.CommandDataImpl;
import parser.temporal.CelebiDateParser;
import parser.temporal.DateParser;
import ui.view.CelebiViewController.Skin;

public class ParserControllerImpl implements ParserController {
	
	/////////////////////////////////////////////////////////////////
	// Patterns for user command arguments matching (trim results)
	/////////////////////////////////////////////////////////////////

	// for whitespace work
	private final Pattern P_WHITESPACE;
	private static final String REG_WHITESPACE = 
			"\\s+";
	
	// regexes for all cmds for consistency
	private static final String REG_MATCHING_NAME_FIELD = regexContaining(Aliases.FIELD_NAME);
	private static final String REG_MATCHING_START_FIELD = regexContaining(Aliases.FIELD_START_DATE);
	private static final String REG_MATCHING_END_FIELD = regexContaining(Aliases.FIELD_END_DATE);
	
	private static final String REG_MATCHING_SHOW_DEFAULT = regexContaining(Aliases.VIEW_DEFAULT);
	private static final String REG_MATCHING_SHOW_COMPLETED = regexContaining(Aliases.VIEW_COMPLETED);
	private static final String REG_MATCHING_SHOW_INCOMPLETE = regexContaining(Aliases.VIEW_INCOMPLETE);
	
	private static final String REG_MATCHING_THEME_DAY = regexContaining(Aliases.THEME_DAY);
	private static final String REG_MATCHING_THEME_NIGHT = regexContaining(Aliases.THEME_NIGHT);
	
	private static final String REG_MATCHING_CLEAR_VAL = regexContaining(Aliases.CLEAR_VAL);
	
	private static final String GRPNAME_NAME = "name";
	private static final String GRPNAME_START = "start";
	private static final String GRPNAME_END = "end";
	private static final String GRPNAME_UID = "uid";
	
	private static final String REG_VALID_NAME = "[^;]+";
	private static final String REG_UNVALIDATED_DATE = ".+"; // still needs to get parsed by date formatter
	private static final String REG_UID = "-?\\d+"; // supports negative numbers for logic to throw exception
	
	private static final String REG_GRP_NAME = regexNamedGrp(REG_VALID_NAME, GRPNAME_NAME);
	private static final String REG_GRP_START = regexNamedGrp(REG_UNVALIDATED_DATE, GRPNAME_START);
	private static final String REG_GRP_END = regexNamedGrp(REG_UNVALIDATED_DATE, GRPNAME_END);
	private static final String REG_GRP_UID = regexNamedGrp(REG_UID, GRPNAME_UID);
	
	////////////////////////////////////////////////////////////////
	// ADD command parsing parameters
	////////////////////////////////////////////////////////////////
	
	private static final String REG_NAME_DATE_DELIM = "\\s*;\\s*";
	
	// <name>
	private final Pattern P_ADD_FLT;
	private static final String REG_ADD_FLT = concatArgs(
		'^',
		REG_GRP_NAME,
		'$'
	);
		
	
	// <name>; <start field identifier> <start>
	private final Pattern P_ADD_START;
	private static final String REG_ADD_START = concatArgs(
		'^',
		REG_GRP_NAME,
		REG_NAME_DATE_DELIM,
		REG_MATCHING_START_FIELD,
		REG_WHITESPACE,
		REG_GRP_START,
		'$'
	);

	// <name>; <end field identifier> <end>
	private final Pattern P_ADD_END;
	private static final String REG_ADD_END = concatArgs(
		'^',
		REG_GRP_NAME,
		REG_NAME_DATE_DELIM,
		REG_MATCHING_END_FIELD,
		REG_WHITESPACE,
		REG_GRP_END,
		'$'
	);

	// <name>; <start field identifier> <start> <end field identifier> <end>
	private final Pattern P_ADD_EVT;
	private static final String REG_ADD_EVT = concatArgs(
		'^',
		REG_GRP_NAME,
		REG_NAME_DATE_DELIM,
		REG_MATCHING_START_FIELD,
		REG_WHITESPACE,
		REG_GRP_START,
		REG_WHITESPACE,
		REG_MATCHING_END_FIELD,
		REG_WHITESPACE,
		REG_GRP_END,
		'$'
	);

	////////////////////////////////////////////////////////////////
	// UPD command parsing parameters
	////////////////////////////////////////////////////////////////
	
	private static final String GRPNAME_NEWVAL = "newval";
	private static final String REG_GRP_NEW_NAME = regexNamedGrp(REG_VALID_NAME, GRPNAME_NEWVAL);
	private static final String REG_GRP_NEW_DATE = regexNamedGrp(REG_UNVALIDATED_DATE, GRPNAME_NEWVAL);
	
	// <field> <uid> <newval>
	private final Pattern P_UPD_NAME;
	private static final String REG_UPD_NAME = concatArgs(
		'^',
		REG_GRP_UID,
		REG_WHITESPACE,
		REG_MATCHING_NAME_FIELD,
		REG_WHITESPACE,
		REG_GRP_NEW_NAME,
		'$'
	);
	private final Pattern P_UPD_START;
	private static final String REG_UPD_START = concatArgs(
		'^',
		REG_GRP_UID,
		REG_WHITESPACE,
		REG_MATCHING_START_FIELD,
		REG_WHITESPACE,
		REG_GRP_NEW_DATE,
		'$'
	);
	private final Pattern P_UPD_END;
	private static final String REG_UPD_END = concatArgs(
		'^',
		REG_GRP_UID,
		REG_WHITESPACE,
		REG_MATCHING_END_FIELD,
		REG_WHITESPACE,
		REG_GRP_NEW_DATE,
		'$'
	);

	////////////////////////////////////////////////////////////////
	// UID arg only command (DEL, MARK, UNMARK, parsing parameters
	////////////////////////////////////////////////////////////////
	
	private static final String REG_UID_ONLY = concatArgs(
		'^',
		REG_GRP_UID,
		'$'
	);

	private final Pattern P_DEL;
	private static final String REG_DEL = REG_UID_ONLY;
	private final Pattern P_MARK;
	private static final String REG_MARK = REG_UID_ONLY;
	private final Pattern P_UNMARK;
	private static final String REG_UNMARK = REG_UID_ONLY;

	
	////////////////////////////////////////////////////////////////
	// SHOW command parsing parameters
	////////////////////////////////////////////////////////////////

	private final Pattern P_SHOW_DEFAULT;
	private static final String REG_SHOW_DEFAULT = concatArgs(
		'^',
		REG_MATCHING_SHOW_DEFAULT,
		'$'
	);
	
	private final Pattern P_SHOW_INCOMPLETE;
	private static final String REG_SHOW_INCOMPLETE = concatArgs(
		'^',
		REG_MATCHING_SHOW_INCOMPLETE,
		'$'
	);
	
	private final Pattern P_SHOW_COMPLETED;
	private static final String REG_SHOW_COMPLETED = concatArgs(
		'^',
		REG_MATCHING_SHOW_COMPLETED,
		'$'
	);
	
	
	////////////////////////////////////////////////////////////////
	// FILTER command parsing parameters
	////////////////////////////////////////////////////////////////

	private static final String GRPNAME_FIL_LO_BOUND = "start";
	private static final String GRPNAME_FIL_HI_BOUND = "end";
	private static final String REG_GRP_FIL_LO_BOUND = 
			regexNamedGrp(REG_UNVALIDATED_DATE, GRPNAME_FIL_LO_BOUND);
	private static final String REG_GRP_FIL_HI_BOUND = 
			regexNamedGrp(REG_UNVALIDATED_DATE, GRPNAME_FIL_HI_BOUND);
	
	// before|bef <key(date,>
	private final Pattern P_FILTER_BEF;
	private static final String REG_FILTER_BEF = concatArgs(
		'^',
		regexContaining(Aliases.FILTER_ARG_BEF),
		REG_WHITESPACE,
		REG_GRP_FIL_HI_BOUND,
		'$'
	);

	// after|aft <key(date,>
	private final Pattern P_FILTER_AFT;
	private static final String REG_FILTER_AFT = concatArgs(
		'^',
		regexContaining(Aliases.FILTER_ARG_AFT),
		REG_WHITESPACE,
		REG_GRP_FIL_LO_BOUND,
		'$'
	);
	
	// between|b/w|btw|from|start <key1(date,> and|to|till|until|end <key2(date,>
	private final Pattern P_FILTER_BTW;
	private static final String REG_FILTER_BTW = concatArgs(
		'^',
		regexContaining(Aliases.FILTER_ARG_BTW_START),
		REG_WHITESPACE,
		REG_GRP_FIL_LO_BOUND,
		REG_WHITESPACE,
		regexContaining(Aliases.FILTER_ARG_BTW_END),
		REG_WHITESPACE,
		REG_GRP_FIL_HI_BOUND,
		'$'
	);
	

	////////////////////////////////////////////////////////////////
	// THEME command parsing parameters
	////////////////////////////////////////////////////////////////

	private final Pattern P_THEME_DAY;
	private static final String REG_THEME_DAY = concatArgs(
		'^',
		REG_MATCHING_THEME_DAY,
		'$'
	);
	private final Pattern P_THEME_NIGHT;
	private static final String REG_THEME_NIGHT = concatArgs(
		'^',
		REG_MATCHING_THEME_NIGHT,
		'$'
	);


	////////////////////////////////////////////////////////////////
	// ALIAS command parsing parameters
	////////////////////////////////////////////////////////////////

	private static final String REG_VALID_CMD = "\\S+";
	private static final String GRPNAME_TARGET_CMD = "target";
	private static final String GRPNAME_ALIAS = "alias";
	private static final String REG_GRP_ALIAS_TARGET = regexNamedGrp(REG_VALID_CMD, GRPNAME_TARGET_CMD);
	private static final String REG_GRP_ALIAS_NEW = regexNamedGrp(REG_VALID_CMD, GRPNAME_ALIAS);
	
	private final Pattern P_ALIAS_NEW;
	private static final String REG_ALIAS_NEW = concatArgs(
		'^',
		REG_GRP_ALIAS_TARGET,
		REG_WHITESPACE,
		REG_GRP_ALIAS_NEW,
		'$'
	);
	private final Pattern P_ALIAS_CLR;
	private static final String REG_ALIAS_CLR = concatArgs(
		'^',
		REG_MATCHING_CLEAR_VAL,
		'$'
	);
	
	
	/////////////////////////////////////////////////////////////////
	// instance fields
	/////////////////////////////////////////////////////////////////
	private String userRawInput;
	private static ParserControllerImpl parserInstance;
	private final CelebiDateParser DATE_FORMATTER;
	private final Aliases ALIASES;

	/////////////////////////////////////////////////////////////////
	
	private ParserControllerImpl() {
		
		userRawInput = "no user input received";
		ALIASES = AliasesImpl.getInstance();
		DATE_FORMATTER = new DateParser();
		
		P_WHITESPACE = Pattern.compile(REG_WHITESPACE);
		
		P_ADD_FLT = Pattern.compile(REG_ADD_FLT, CASE_INSENSITIVE);
		P_ADD_START = Pattern.compile(REG_ADD_START, CASE_INSENSITIVE);
		P_ADD_END = Pattern.compile(REG_ADD_END, CASE_INSENSITIVE);
		P_ADD_EVT = Pattern.compile(REG_ADD_EVT, CASE_INSENSITIVE);
		
		P_UPD_NAME = Pattern.compile(REG_UPD_NAME, CASE_INSENSITIVE);
		P_UPD_START = Pattern.compile(REG_UPD_START, CASE_INSENSITIVE);
		P_UPD_END = Pattern.compile(REG_UPD_END, CASE_INSENSITIVE);
		
		P_DEL = Pattern.compile(REG_DEL, CASE_INSENSITIVE);
		P_MARK = Pattern.compile(REG_MARK, CASE_INSENSITIVE);
		P_UNMARK = Pattern.compile(REG_UNMARK, CASE_INSENSITIVE);
		
		P_SHOW_DEFAULT = Pattern.compile(REG_SHOW_DEFAULT);
		P_SHOW_INCOMPLETE = Pattern.compile(REG_SHOW_INCOMPLETE);
		P_SHOW_COMPLETED = Pattern.compile(REG_SHOW_COMPLETED);
		
		P_FILTER_BEF = Pattern.compile(REG_FILTER_BEF, CASE_INSENSITIVE);
		P_FILTER_AFT = Pattern.compile(REG_FILTER_AFT, CASE_INSENSITIVE);
		P_FILTER_BTW = Pattern.compile(REG_FILTER_BTW, CASE_INSENSITIVE);
		
		P_THEME_DAY = Pattern.compile(REG_THEME_DAY);
		P_THEME_NIGHT = Pattern.compile(REG_THEME_NIGHT);
		
		P_ALIAS_NEW = Pattern.compile(REG_ALIAS_NEW);
		P_ALIAS_CLR = Pattern.compile(REG_ALIAS_CLR);
	}
	// singleton access
	public static ParserControllerImpl getParser() {
		if (parserInstance == null) {
			parserInstance = new ParserControllerImpl();
		}
		return parserInstance;
	}
	
	@Override
	public void init() {
		System.out.println("Parser Init");
		System.out.println("Parser Init complete");
	}

	private static final String regexContaining(String[] tokens) {
		final StringBuilder sb = new StringBuilder();
		sb.append("(?:");
		for (String tok : tokens) {
			sb.append("\\Q").append(tok).append("\\E"); // necesary escaping
			sb.append('|');
		}
		if (tokens.length > 0) { 
			sb.deleteCharAt(sb.length() - 1);
		}
		sb.append(')');
		return sb.toString();
	}
	private static final String regexNamedGrp(String regex, String grpName) {
		final StringBuilder sb = new StringBuilder();
		sb.append("(?");
		sb.append('<').append(grpName).append('>');
		sb.append(regex);
		sb.append(')');
		return sb.toString();
}
	private static final String concatArgs(Object... args) {
		final StringBuilder sb = new StringBuilder();
		for (Object item : args) {
			sb.append(item);
		}
		return sb.toString();
	}
	
	@Override
	public CommandDataImpl parseCommandData(String rawInput) {
		assert(rawInput != null);
		// TODO rework to not use String.split
		userRawInput = rawInput;
		// Splits input string at first whitespace substring, trimming trailing whitespace
		String[] cmdAndArgs = P_WHITESPACE.split(rawInput.trim(), 2);
		// if no command args, set the args half of the array to empty string
		if (cmdAndArgs.length != 2) { 
			cmdAndArgs = new String[]{cmdAndArgs[0], ""};
		}
		CommandData.Type cmdType = parseCmdType(cmdAndArgs[0]);
		return passArgs(cmdType, cmdAndArgs[1]);
	}
	
	private CommandData.Type parseCmdType(String token) {
		assert(token != null);
		token = cleanText(token);
		
		final CommandData.Type cmdType = ALIASES.getCmdFromAlias(token);
		return cmdType == null ? CommandData.Type.INVALID : cmdType;
	}

	private CommandDataImpl passArgs(CommandData.Type type, String args) {
		assert(type != null && args != null);
		args = args.trim();
		switch (type) {
			case ADD :
				return parseAdd(args);
				//break;
			case DELETE : 
				return parseDel(args);
				//break;
			case UPDATE : 
				return parseUpd(args);
				//break;
			case QUIT :
				return parseQuit(args);
				//break;
			case INVALID :
				return makeInvalid();
				//break;
			case SHOW :
				return parseShow(args);
				//break;
			case REDO :
				return parseRedo(args);
				//break;
			case UNDO :
				return parseUndo(args);
				//break;
			case MARK :
				return parseMark(args);
				//break;
			case UNMARK :
				return parseUnmark(args);
				//break;
			case SEARCH :
				return parseSearch(args);
				//break;
			case FILTER_DATE :
				return parseFilterDate(args);
				//break;
			case MOVE:
				return parseMove(args);
				//break;
			case HELP:
				return parseHelp(args);
				//break;
			case CLEAR_FILTERS:
				return parseClear(args);
			case THEME :
				return parseTheme(args);
				//break;
			case ALIAS :
				return parseAlias(args);
				//break;
			default :
				break;
			}
		assert(false); // should never happen
		return null;
	}

	private CommandDataImpl parseAdd(String args) {
		assert(args != null);
		args = args.trim();
		
		Matcher m;
		Date start, end;
		String name;
		
		m = P_ADD_FLT.matcher(args);
		if (m.matches()) {
			name = m.group(GRPNAME_NAME).trim();
			start = null;
			end = null;
			return makeAdd(name, start, end);
		}
		try {
			// must put more restrictive regexes in front
			// to prevent looser regexes accidentally capturing
			// string that should have matched the former!!!!
			m = P_ADD_EVT.matcher(args);
			if (m.matches()) {
				name = m.group(GRPNAME_NAME).trim();
				start = parseDate(m.group(GRPNAME_START).trim(), true);
				end = parseDate(m.group(GRPNAME_END).trim(), false);
				return makeAdd(name, start, end);
			}
			
			m = P_ADD_START.matcher(args);
			if (m.matches()) {
				name = m.group(GRPNAME_NAME).trim();
				start = parseDate(m.group(GRPNAME_START).trim(), true);
				end = null;
				return makeAdd(name, start, end);
			}
			
			m = P_ADD_END.matcher(args);
			if (m.matches()) {
				name = m.group(GRPNAME_NAME).trim();
				start = null;
				end = parseDate(m.group(GRPNAME_END).trim(), false);
				return makeAdd(name, start, end);
			}			
		} catch (ParseException pe) {
			//System.out.println(pe);
		}
		return makeInvalid();
	}
	private CommandDataImpl parseDel(String args) {
		assert(args != null);
		args = args.trim();
		Matcher m = P_DEL.matcher(args);
		if (m.matches()) {
			try {
				int uid = Integer.parseInt(m.group(GRPNAME_UID));
				return makeDelete(uid);
			} catch (Exception e) {
				System.out.println(e);
			}
		}
		return makeInvalid();
	}
	private CommandDataImpl parseUpd(String args) {
		assert(args != null);
		
		int uid;
		Matcher m;
		final String newName;
		final Date newStart;
		final Date newEnd;
		String newValue;
		
		m = P_UPD_NAME.matcher(args);
		if (m.matches()) {
			uid = Integer.parseInt(m.group(GRPNAME_UID));
			newValue = m.group(GRPNAME_NEWVAL);
			newName = newValue.trim();
			return makeUpdateName(uid, newName);
		}

		try {
			m = P_UPD_START.matcher(args);
			if (m.matches()) {
				uid = Integer.parseInt(m.group(GRPNAME_UID));
				newValue = m.group(GRPNAME_NEWVAL);
				newStart = parseUpdDate(newValue, true);
				return makeUpdateStart(uid, newStart);
			}
	
			m = P_UPD_END.matcher(args);
			if (m.matches()) {
				uid = Integer.parseInt(m.group(GRPNAME_UID));
				newValue = m.group(GRPNAME_NEWVAL);
				newEnd = parseUpdDate(newValue, false);
				return makeUpdateEnd(uid, newEnd);
			}
		} catch (ParseException pe) {
			//System.out.println(pe);
		}
		return makeInvalid();
	}
	private CommandDataImpl parseQuit (String args) {
		assert(args != null);
		return makeQuit();
	}
	private CommandDataImpl parseShow (String args) {
		assert(args != null);
		args = cleanText(args);
		
		Matcher m;
		TasksBag.ViewType view;
		
		m = P_SHOW_DEFAULT.matcher(args);
		if (m.matches()) {
			view = TasksBag.ViewType.DEFAULT;
			return makeShow(view);
		}
		
		m = P_SHOW_INCOMPLETE.matcher(args);
		if (m.matches()) {
			view = TasksBag.ViewType.INCOMPLETE;
			return makeShow(view);
		}
		
		m = P_SHOW_COMPLETED.matcher(args);
		if (m.matches()) {
			view = TasksBag.ViewType.COMPLETED;
			return makeShow(view);
		}
		

		return makeInvalid();
	}
	private CommandDataImpl parseRedo (String args) {
		assert(args != null);
		return makeRedo();
	}
	private CommandDataImpl parseUndo (String args) {
		assert(args != null);
		return makeUndo();
	}
	private CommandDataImpl parseMark (String args) {
		assert(args != null);
		args = args.trim();
		final Matcher m = P_MARK.matcher(args);
		if (m.matches()) {
			final int uid = Integer.parseInt(m.group(GRPNAME_UID));
			return makeMark(uid);
		}
		return makeInvalid();
	}
	private CommandDataImpl parseUnmark (String args) {
		assert(args != null);
		args = args.trim();
		final Matcher m = P_UNMARK.matcher(args);
		if (m.matches()) {
			final int uid = Integer.parseInt(m.group(GRPNAME_UID));
			return makeUnmark(uid);
		}
		return makeInvalid();
	}
	private CommandDataImpl parseSearch (String args) {
		assert(args != null);
		args = args.trim();
		if (args.length() != 0) {
			return makeSearch(args);
		}
		return makeInvalid();
	}
	private CommandDataImpl parseFilterDate (String args) {
		assert(args != null);
		args = args.trim();
		
		Matcher m;
		Date min, max;

		m = P_FILTER_BTW.matcher(args);
		if (m.matches()) {
			try {
				min = parseDate(m.group(GRPNAME_FIL_LO_BOUND), true);
				max = parseDate(m.group(GRPNAME_FIL_HI_BOUND), false);
				return makeFilterDate(min, max);
			} catch (ParseException pe) {
				;
			}
		}
		
		m = P_FILTER_BEF.matcher(args);
		if (m.matches()) {
			try {
				max = parseDate(m.group(GRPNAME_FIL_HI_BOUND), false);
				min = Utilities.absBeginningTime();//new Date(0);
				return makeFilterDate(min, max);
			} catch (ParseException pe) {
				;
			}
		}
		
		m = P_FILTER_AFT.matcher(args);
		if (m.matches()) {
			try {
				min = parseDate(m.group(GRPNAME_FIL_LO_BOUND), true);
				max = Utilities.absEndingTime();//new Date(Long.MAX_VALUE);
				return makeFilterDate(min, max);
			} catch (ParseException pe) {
				;
			}
		}
		
		return makeInvalid();
	}
	private CommandDataImpl parseClear (String args) {
		assert(args != null);
		return makeClear();
	}
	private CommandDataImpl parseMove (String args) {
		assert(args != null);
		args = args.trim();
		if (args.length() != 0) {
			try {
				Path p = parsePath(args.trim());
				return makeMove(p);
			} catch (ParseException pe) {
				;
			}
		}
		return makeInvalid();
	}
	private CommandDataImpl parseHelp (String args) {
		assert(args != null);
		args = args.trim();
		if (args.length() == 0) { // no args for help cmd
			return makeHelp(null);
		}
		CommandData.Type helpTarget = parseCmdType(args);
		// help args can be parsed into a cmd type
		if (helpTarget != CommandData.Type.INVALID) {
			return makeHelp(helpTarget);
		}
		return makeInvalid();
	}
	private CommandDataImpl parseTheme (String args) {
		assert(args != null);
		args = cleanText(args);
		
		Matcher m;
		
		m = P_THEME_DAY.matcher(args);
		if (m.matches()) {
			return makeTheme(Skin.DAY);
		}
		
		m = P_THEME_NIGHT.matcher(args);
		if (m.matches()) {
			return makeTheme(Skin.NIGHT);
		}

		return makeInvalid();
	}
	private CommandDataImpl parseAlias (String args) {
		assert(args != null);
		args = cleanText(args);
		
		final CommandData.Type target;
		final String alias;
		Matcher m;
		
		m = P_ALIAS_CLR.matcher(args);
		if (m.matches()) {
			return makeAlias(null, null);
		}
		
		m = P_ALIAS_NEW.matcher(args);
		if (m.matches()) {
			target = parseCmdType(cleanText(m.group(GRPNAME_TARGET_CMD)));
			alias = cleanText(m.group(GRPNAME_ALIAS)); // can be any non whitespace string
			if (target != CommandData.Type.INVALID ) {
				return makeAlias(alias, target);
			}
		}
		
		return makeInvalid();
	}
	
	// cleans a string by trimming trailing whitespace and shifting alpha to lowercase
	public static String cleanText (String token) {
		assert(token != null);
		return token.trim().toLowerCase();
	}
	Date parseDate (String token, boolean isStart) throws ParseException {
		assert(token != null);
		return DATE_FORMATTER.parseDate(token, isStart);
	}
	public static Path parsePath (String token) throws ParseException {
		assert(token != null);
		return Paths.get(token.trim());
	}
	// Used only in parseUpdate: allows special datestrings
	// to signify removal of a date field from the task.
	// Allows conversion from event->deadline/startonly->float
	private Date parseUpdDate (String dateStr, boolean isStart) throws ParseException {
		assert(dateStr != null);
		cleanText(dateStr);
		final List<String> clearDateAliases = Arrays.asList(Aliases.CLEAR_VAL);
		if (clearDateAliases.contains(dateStr)) {
			return null;
		}
		return parseDate(dateStr, isStart);
	}
	
	
	public CommandDataImpl makeAdd (String name, Date start, Date end) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.ADD, userRawInput);
		cmd.setEnd(end);
		cmd.setStart(start);
		cmd.setText(name);
		return cmd;
	}
	
	public CommandDataImpl makeUpdateName (int taskUID, String newName) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.UPDATE, userRawInput);
		cmd.setTaskField(Task.DataType.NAME);
		cmd.setTaskUID(taskUID);
		cmd.setText(newName);
		return cmd;	
	}
	
	public CommandDataImpl makeUpdateStart (int taskUID, Date newDate) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.UPDATE, userRawInput);
		cmd.setTaskField(Task.DataType.DATE_START);
		cmd.setTaskUID(taskUID);
		cmd.setStart(newDate);
		return cmd;	
	}
	
	public CommandDataImpl makeUpdateEnd (int taskUID, Date newDate) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.UPDATE, userRawInput);
		cmd.setTaskField(Task.DataType.DATE_END);
		cmd.setTaskUID(taskUID);
		cmd.setEnd(newDate);
		return cmd;	
	}
	
	public CommandDataImpl makeDelete (int taskUID) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.DELETE, userRawInput);
		cmd.setTaskUID(taskUID);
		return cmd;
	}
	
	public CommandDataImpl makeShow (TasksBag.ViewType view) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.SHOW, userRawInput);
		cmd.setViewType(view);
		return cmd;		
	}
	
	public CommandDataImpl makeRedo () {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.REDO, userRawInput);
		return cmd;
	}
	
	public CommandDataImpl makeUndo () {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.UNDO, userRawInput);
		return cmd;
		
	}
	
	public CommandDataImpl makeMark (int taskUID) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.MARK, userRawInput);
		cmd.setTaskUID(taskUID);
		return cmd;
	}
	
	public CommandDataImpl makeUnmark (int taskUID) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.UNMARK, userRawInput);
		cmd.setTaskUID(taskUID);
		return cmd;
	}
	
	public CommandDataImpl makeSearch (String keywords) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.SEARCH, userRawInput);
		cmd.setText(keywords);
		return cmd;
	}
	
	public CommandDataImpl makeFilterDate (Date rangeStart, Date rangeEnd) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.FILTER_DATE, userRawInput);
		cmd.setStart(rangeStart);
		cmd.setEnd(rangeEnd);
		return cmd;
	}
	
	public CommandDataImpl makeClear () {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.CLEAR_FILTERS, userRawInput);
		return cmd;
	}
	
	public CommandDataImpl makeMove (Path newPath) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.MOVE, userRawInput);
		cmd.setPath(newPath);
		return cmd;
	}
	
	public CommandDataImpl makeHelp (CommandData.Type helpTarget) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.HELP, userRawInput);
		cmd.setSecondaryCmdType(helpTarget);
		return cmd;
	}
	
	public CommandDataImpl makeQuit () {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.QUIT, userRawInput);
		return cmd;
	}
	
	public CommandDataImpl makeTheme (Skin theme) {
        final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.THEME, userRawInput);
	    cmd.setTheme(theme);
	    return cmd;
	}
	
	public CommandDataImpl makeAlias (String alias, CommandData.Type target) {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.ALIAS, userRawInput);
		cmd.setText(alias);
		cmd.setSecondaryCmdType(target);
		return cmd;
	}
	
	public CommandDataImpl makeInvalid () {
		final CommandDataImpl cmd = new CommandDataImpl(CommandData.Type.INVALID, userRawInput);
		return cmd;
	}
	
	public static void printCmd(CommandData c) {
		System.out.println("type: " + c.getCmdType());
		System.out.println("raw: " + c.getRawUserInput());
		System.out.print("uid: " + c.getTaskUID());
		System.out.println("   fieldkey: " + c.getTaskField());
		System.out.println("name: " + c.getText());
		System.out.print("start: " + c.getStart());
		System.out.println("   end: "+ c.getEnd());
		System.out.println("2nd cmd type: " + c.getSecondaryCmdType());
	}
	
	public static void main(String[] args) throws Exception {
		@SuppressWarnings("resource")
		Scanner sc = new Scanner(System.in);
		ParserControllerImpl p = new ParserControllerImpl();
		while (true) {
//			System.out.println(p.P_ADD_FLT.pattern());
//			System.out.println(p.P_ADD_FLT.matcher(sc.nextLine()).matches());
			printCmd(p.parseCommandData(sc.nextLine()));
		}
	}
}
```
###### src\parser\ParserTest.java
``` java
package parser;

import static org.junit.Assert.*;
import org.junit.Test;

import parser.commands.CommandData;
import parser.commands.CommandDataImpl;

import org.junit.Before;

import java.util.Random;
import java.nio.charset.*;

public class ParserTest {

	private ParserControllerImpl P;
	private Random RNG;
	private static final Charset CHARSET = StandardCharsets.UTF_8;
	
	private static final int FIRST_KEY_CAPTURABLE_CHAR = 0x20;
	private static final int LAST_KEY_CAPTURABLE_CHAR = 0x7E;
	private static final int KEY_CAPTURABLE_RANGE = LAST_KEY_CAPTURABLE_CHAR - FIRST_KEY_CAPTURABLE_CHAR + 1;
	
	private static final int NUM_RANDOM_RETESTS = 32;
	private static final int MAX_RANDOM_GENERATED_BYTES = 100; // largest random string size generatable
	
	private static final String[] VALID_CMD_TOKENS = {
			"a", "add", "new", "create",
			"d", "del", "delete", "rm", "remove",
			"u", "upd", "update", "set", "edit",
			"q", "quit", "exit",
			"mark", "complete",
			"unmark", "reopen",
			"un", "undo",
			"re", "redo",
			"show"
	};
	
	@Before
	public void setUp () {
		RNG = new Random();
		P = ParserControllerImpl.getParser();
	}
	
	
	/** Tests invalid command tokens in input string
	 * no boundary cases 
	 * 
	 */
	@Test
	public void testInvalidCmdToken () {
		StringBuilder testInput;
		CommandDataImpl cmd;
		// test random inputs with guaranteed invalid command tokens 
		for (int i = 0; i < NUM_RANDOM_RETESTS; i++) {
			testInput = new StringBuilder(randInvalidCmdToken());
			testInput.append(' ');
			testInput.append(randInputString());
			System.out.println(testInput);
			// testInput now holds a random command token + a space + random data
			cmd = P.parseCommandData(testInput.toString());
			
			if (cmd.getCmdType() != CommandData.Type.INVALID) {
				ParserControllerImpl.printCmd(cmd);
				fail("invalid command token string does not correctly return INVALID\n");
			}
		}		
	}
	// returns a random string without spaces and not equal to any of the valid_cmd_tokens,
	private String randInvalidCmdToken () {
		while (true) {
			
			byte[] strByteArray = new byte[RNG.nextInt(MAX_RANDOM_GENERATED_BYTES)];

			// seed with random keyboard enterable characters. (random character in range defined by FIRST/LAST_KEY_CAPTURABLE_CHAR)
			for (int i = 0; i < strByteArray.length; i++) {
				// +1 -1 to exclude spaces
				strByteArray[i] = (byte) (FIRST_KEY_CAPTURABLE_CHAR+1 + RNG.nextInt(KEY_CAPTURABLE_RANGE-1));
			}
			
			String randCmdToken = new String(strByteArray);
			if (!isValidCmdToken(randCmdToken)) {
				return randCmdToken;
			}
		}
	}
	private boolean isValidCmdToken (String testee) {
		for (String validCmdToken : VALID_CMD_TOKENS) {
			if (testee.equals(validCmdToken)) {
				return true;
			}
		}
		return false;
	}
	private String randInputString () {
		byte[] bytes = new byte[RNG.nextInt(MAX_RANDOM_GENERATED_BYTES)];
		for (int i = 0; i < bytes.length; i++) {
			bytes[i] = randKeyCapturableByte();
		}
		return new String(bytes);
	}
	private byte randKeyCapturableByte () {
		return (byte) (FIRST_KEY_CAPTURABLE_CHAR + RNG.nextInt(KEY_CAPTURABLE_RANGE));
	}
	
	/**
	 *  ADD TESTS:
	 *  NAME: STRING [ANY STRING WITHOUT SEMICOLONS]
	 */
	
	@Test
	public void testAddWithValidName () {
		// 
		CommandDataImpl cmd = P.parseCommandData("add ");
	}

	//private String getRandomVa
}
```
###### src\parser\temporal\CelebiDateParser.java
``` java
package parser.temporal;

import java.text.ParseException;
import java.util.Date;

public interface CelebiDateParser {
	public Date parseDate (String dateStr, boolean isStart) throws ParseException;
	//public String formatDate (Date d);
}
```
###### src\parser\temporal\ConvenienceDateFormat.java
``` java
package parser.temporal;

import static java.util.Calendar.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Scanner;

import common.Configuration;
import common.Time;
public class ConvenienceDateFormat implements CelebiDateParser {
	
	public ConvenienceDateFormat () {
		// TODO Auto-generated constructor stub
	}

	@Override
	public Date parseDate (String s, boolean isStart) throws ParseException {
		Calendar cal = new GregorianCalendar();
		Time t;
		if (isStart) {
			t = Configuration.getInstance().getDefaultStartTime();
		} else {
			t = Configuration.getInstance().getDefaultEndTime();
		}
		cal.set(HOUR_OF_DAY, t.getHour());
		cal.set(MINUTE, t.getMin());
		switch (s.trim().toLowerCase()) {
		
			case "none" :
			case "empty" :
			case "clear" :
			case "remove" :
			case "null" :
				return null;
		
			// current time
			case "now" :
				return new Date();
				
			case "today" :
				return cal.getTime();
				
			// +24h
			case "tmr" :		// Fallthrough
			case "tomorrow" :
				cal.add(DAY_OF_YEAR, 1);
				return cal.getTime();
				
			// +24*7h
			case "next week" :
				cal.add(WEEK_OF_YEAR, 1);
				return cal.getTime();
				
			case "sun" :
			case "sunday" :
				cal.set(DAY_OF_WEEK, SUNDAY);
				return cal.getTime();
			case "mon" :
			case "monday" :
				cal.set(DAY_OF_WEEK, MONDAY);
				return cal.getTime();
			case "tue" :
			case "tues" :
			case "tuesday" :
				cal.set(DAY_OF_WEEK, TUESDAY);
				return cal.getTime();
			case "wed" :
			case "wednesday" :
				cal.set(DAY_OF_WEEK, WEDNESDAY);
				return cal.getTime();
			case "thu" :
			case "thur" :
			case "thurs" :
			case "thursday" :
				cal.set(DAY_OF_WEEK, THURSDAY);
				return cal.getTime();
			case "fri" :
			case "friday" :
				cal.set(DAY_OF_WEEK, FRIDAY);
				return cal.getTime();
			case "sat" :
			case "saturday" :
				cal.set(DAY_OF_WEEK, SATURDAY);
				return cal.getTime();
			
			case "next mon" :
			case "next monday" :
				cal.add(WEEK_OF_YEAR, 1);
				cal.set(DAY_OF_WEEK, MONDAY);
				return cal.getTime();
				
			case "next tue" :
			case "next tues" :
			case "next tuesday" :
				cal.add(WEEK_OF_YEAR, 1);
				cal.set(DAY_OF_WEEK, TUESDAY);
				return cal.getTime();
				
			case "next wed" :
			case "next wednesday" :
				cal.add(WEEK_OF_YEAR, 1);
				cal.set(DAY_OF_WEEK, WEDNESDAY);
				return cal.getTime();
				
			case "next thu" :
			case "next thur" :
			case "next thursday" :
				cal.add(WEEK_OF_YEAR, 1);
				cal.set(DAY_OF_WEEK, THURSDAY);
				return cal.getTime();
				
			case "next fri" :
			case "next friday" :
				cal.add(WEEK_OF_YEAR, 1);
				cal.set(DAY_OF_WEEK, FRIDAY);
				return cal.getTime();

			case "next sat" :
			case "next saturday" :
				cal.add(WEEK_OF_YEAR, 1);
				cal.set(DAY_OF_WEEK, SATURDAY);
				return cal.getTime();

			case "next sun" :
			case "next sunday" :
				cal.add(WEEK_OF_YEAR, 1);
				cal.set(DAY_OF_WEEK, SUNDAY);
				return cal.getTime();
				
			default:
				throw new ParseException("", -1);
		}
	}
	
	public static void main (String[] args) {
		@SuppressWarnings("resource")
		Scanner sc = new Scanner(System.in);
		SimpleDateFormat df = new SimpleDateFormat("EEE");
		while (true) {
			try {
				GregorianCalendar cal = new GregorianCalendar();
				GregorianCalendar cal2 = new GregorianCalendar();
				cal.setTime(df.parse(sc.nextLine()));
				cal2.set(Calendar.DAY_OF_WEEK, cal.get(Calendar.DAY_OF_WEEK));
				System.out.println(cal2.getTime());
			} catch (ParseException pe) {
				;
			}
		}
	}
}
```
###### src\parser\temporal\DateParser.java
``` java
package parser.temporal;

import java.text.ParseException;
import java.util.Date;
import java.util.Scanner;
import java.util.regex.Pattern;

public class DateParser implements CelebiDateParser {
	
	/////////////////////////////////////////////////////////////////
	// Preprocess datestring
	/////////////////////////////////////////////////////////////////
	
	// For separating intra-date tokens, matching characters {'-'|'_'|' '|'/'|'\'|'.'|':'}
	private static final String REGEX_DATETIME_DELIM = 
		"[\\Q-_/\\.: \\E]+";
	private final Pattern P_DATETIME_DELIM;
	
	// For separating date and time portions, matching chars {','|';'}
	private static final String REGEX_DATETIME_SEP =
		"\\s*[;,]+\\s*";
	private final Pattern P_DATETIME_SEP;
	
	// placeholder strings for pattern matching tokenisation
	public static final String DATETIME_DELIM = "*";
	public static final String DATETIME_SEP = "|";
	

	/////////////////////////////////////////////////////////////////
	// Worker classes for parsing different date formats
	/////////////////////////////////////////////////////////////////
	
	private final CelebiDateParser CONV_DF;
	private final CelebiDateParser FULL_DF;
	private final CelebiDateParser PART_DF;

	public DateParser() {
		P_DATETIME_DELIM = Pattern.compile(REGEX_DATETIME_DELIM);
		P_DATETIME_SEP = Pattern.compile(REGEX_DATETIME_SEP);
		FULL_DF = new FullDateFormat();
		PART_DF = new PartialDateFormat();
		CONV_DF = new ConvenienceDateFormat();
	}

	public Date parseDate (String token, boolean isStart) throws ParseException {
		assert(token != null);
		token = token.trim().toLowerCase();
		try {
			return CONV_DF.parseDate(token, isStart);
		} catch (ParseException pe) {
			return parseAbsDate(token, isStart);
		}
	}
	Date parseAbsDate (String token, boolean isStart) throws ParseException {
		assert(token != null);
		
		// replace date delimiters with common token
		token = token.trim();
		token = P_DATETIME_SEP.matcher(token).replaceAll(DATETIME_SEP); // process date-time seperator
		token = P_DATETIME_DELIM.matcher(token).replaceAll(DATETIME_DELIM); // process token delims
		
		// try parse with full info, down to minute resolution.
		try { 
			return FULL_DF.parseDate(token, isStart);
		} catch (ParseException pePart) {
			;
		}
		
		// final try: parsing partial dates (without all calendar fields filled).
		try { 
			return PART_DF.parseDate(token, isStart);
		} catch (ParseException peFull) {
			;
		}
		
		throw new ParseException("Unparseable as Date: \"" + token + '"', 0);
	}
	
	public String formatDate (Date d) {
		// TODO
		return null;
	}
	
	public static void main (String[] args) {
		DateParser df = new DateParser();
		@SuppressWarnings("resource")
		Scanner in = new Scanner(System.in);
		while (true) {
			try {
				System.out.println(df.parseDate(in.nextLine(), true));
			} catch (ParseException pe) {
				System.out.println(pe);
			}
		}
	}
}
```
###### src\parser\temporal\FullDateFormat.java
``` java
package parser.temporal;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;
import java.util.regex.Pattern;

import common.Utilities;

import java.util.GregorianCalendar;
import static java.util.Calendar.*;

public class FullDateFormat implements CelebiDateParser {
	
	public static final String DELIM = DateParser.DATETIME_DELIM;
	public static final String SEP = DateParser.DATETIME_SEP;
	
	private static final String REGEX_NUM_SUFFIX = 
			"(\\d)(?:st|nd|rd|th)"; 	// $1 to capture preceding digit
	private final Pattern P_NUM_SUFFIX; // to match the "st" in 1st, "nd" in 2nd, etc..
	
	// parse for time section
	private static final String[] REGEX_TIMES = {
			String.format("hh%smm%<sa", DELIM),	// delim b/w digits and meridian
			String.format("hh%smma", DELIM), 	// no delim b/w digits and meridian
			String.format("HH%smm", DELIM)		// no meridian, 24h
	};
	private final DateFormat[] TIME_DFS;
	
	// parse for date section (cal day)
	private static final String[] REGEX_DATES = {
			String.format("MMM%sdd%<syy", DELIM),
			String.format("dd%sM%<syy", DELIM), 	// for handling numbered months
			String.format("dd%sMMM%<syy", DELIM), 	// for handling text months
			String.format("yy%sM%<sdd", DELIM), 	// yy/mm/dd is lower in prio than dd/mm/yy
			String.format("yy%sMMM%<sdd", DELIM)	// ditto, for text months
	};
	private final DateFormat[] DATE_DFS;

	private GregorianCalendar cal;
	
	FullDateFormat () {
		
		P_NUM_SUFFIX = Pattern.compile(REGEX_NUM_SUFFIX);
		
		TIME_DFS = regexesToDFs(REGEX_TIMES); // Time parsing setup
		DATE_DFS = regexesToDFs(REGEX_DATES); // Date (day) parsing setup
		
	}
	private DateFormat[] regexesToDFs (String[] regexes) {
		final Date twoDigitYearStart = Utilities.absBeginningTime();//new Date(0); // Sets 2 digit year parsing to begin from 1970
		final DateFormat[] dfs = new DateFormat[regexes.length];
		for (int i = 0; i < dfs.length; i++) {
			dfs[i] = new SimpleDateFormat(regexes[i]);
			dfs[i].setLenient(false);
			((SimpleDateFormat)dfs[i]).set2DigitYearStart(twoDigitYearStart);
		}
		return dfs;
	}
	
	// Takes in datestring preprocessed by DateParser to handle all seperators and delimiters
	@Override
	public Date parseDate (String token, boolean isStart) throws ParseException {

		cal = new GregorianCalendar();
		
		// removes all num suffixes
		token = removeNumSuffixes(token);
		
		// split datestring into date and time parts
		String[] split = token.split("\\Q"+SEP+"\\E");
		if (split.length != 2) {
			//System.out.println(split.length);
			throw new ParseException("datestring cannot be split into 2 parts (time and date)", -1);
		}
		
		Date timeD, dateD;
		dateD = dfParse(split[0], DATE_DFS); // try parse first half as time segment
		if (dateD == null) { 	// first half cannot be parsed as time
			dateD = dfParse(split[1], DATE_DFS);
			timeD = dfParse(split[0], TIME_DFS);
		} else { 				// first half successfully parsed as time
			timeD = dfParse(split[1], TIME_DFS);
		}
		
		if (timeD == null || dateD == null) {
			//System.out.println(split);
			//System.out.println("time: " + timeD + "\ndate: " + dateD);
			throw new ParseException("datestring cannot be parsed as full absolute date", -1);
		}
		
		cal.setTime(dateD);
		GregorianCalendar timeCal = new GregorianCalendar();
		timeCal.setTime(timeD);
		cal.set(HOUR_OF_DAY, timeCal.get(HOUR_OF_DAY)); // load hour
		cal.set(MINUTE, timeCal.get(MINUTE)); 			// load minute
		
		return cal.getTime();
	}
	
	private Date dfParse (String token, DateFormat[] dfs) {
		for (DateFormat df : dfs) {
			try {
				return df.parse(token);
			} catch (ParseException pe) {
				;
			}
		}
		return null;
	}
	private String removeNumSuffixes (String s) {
		return P_NUM_SUFFIX.matcher(s).replaceAll("$1");
	}

	// Expl testing
	public static void main (String[] args) throws Exception {
		@SuppressWarnings("resource")
		Scanner in = new Scanner(System.in);
		CelebiDateParser fdf = new FullDateFormat();
		while (true) {
			try {
			System.out.println(fdf.parseDate(in.nextLine(), true));
			} catch (ParseException e) {
				System.out.println(e);
			}
		}
	}

}
```
###### src\parser\temporal\PartialDateFormat.java
``` java
package parser.temporal;

import static java.util.Calendar.DAY_OF_MONTH;
import static java.util.Calendar.DAY_OF_WEEK;
import static java.util.Calendar.HOUR_OF_DAY;
import static java.util.Calendar.MINUTE;
import static java.util.Calendar.MONTH;
import static java.util.Calendar.YEAR;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Scanner;
import java.util.regex.Pattern;

import common.Configuration;
import common.Time;

public class PartialDateFormat implements CelebiDateParser {
	
	public static final String DELIM = DateParser.DATETIME_DELIM;
	public static final String SEP = DateParser.DATETIME_SEP;
	
	private static final String REGEX_NUM_SUFFIX = 
			"(\\d)(?:st|nd|rd|th)"; 	// $1 to capture preceding digit
	private final Pattern P_NUM_SUFFIX; // to match the "st" in 1st, "nd" in 2nd, etc..

	// parse for date section (cal day)
	private final DateFormat[] DATE_YMD_DFS;
	private static final String[] REGEX_YMD_DATES = {
			String.format("MMM%sdd%<syy", DELIM),
			String.format("dd%sM%<syy", DELIM), 	// for handling numbered months
			String.format("dd%sMMM%<syy", DELIM), 	// for handling text months
			String.format("yy%sM%<sdd", DELIM), 	// yy/mm/dd is lower in prio than dd/mm/yy
			String.format("yy%sMMM%<sdd", DELIM)	// ditto, for text months
	};

	private final DateFormat[] DATE_MD_DFS;
	private static final String[] REGEX_MD_DATES = {
			String.format("dd%sMMM", DELIM),		// no year, text month
			String.format("MMM%sdd", DELIM),
			String.format("dd%sM", DELIM), 			// no year, digit month
			String.format("M%sdd", DELIM),
	};
	
	private final DateFormat[] DATE_D_DFS;
	private static final String[] REGEX_D_DATES = {
			String.format("dd")					// only day (num)
	};
	private final DateFormat[] DATE_WD_DFS;
	private static final String[] REGEX_WD_DATES = {
			String.format("EEE")					// only day (weekday name)
	};

	
	private GregorianCalendar cal;
	
	PartialDateFormat () {

		P_NUM_SUFFIX = Pattern.compile(REGEX_NUM_SUFFIX);
	
		DATE_YMD_DFS = regexesToDFs(REGEX_YMD_DATES);
		DATE_MD_DFS = regexesToDFs(REGEX_MD_DATES);
		DATE_D_DFS = regexesToDFs(REGEX_D_DATES);
		DATE_WD_DFS = regexesToDFs(REGEX_WD_DATES);
		
	}
	
	private DateFormat[] regexesToDFs (String[] regexes) {
		final Date twoDigitYearStart = new Date(0); // Sets 2 digit year parsing to begin from 1970
		final DateFormat[] dfs = new DateFormat[regexes.length];
		for (int i = 0; i < dfs.length; i++) {
			dfs[i] = new SimpleDateFormat(regexes[i]);
			dfs[i].setLenient(false);
			((SimpleDateFormat)dfs[i]).set2DigitYearStart(twoDigitYearStart);
		}
		return dfs;
	}
	
	@Override
	public Date parseDate (String token, boolean isStart) throws ParseException {
		
		cal = new GregorianCalendar();
		Time t;
		if (isStart) {
			t = Configuration.getInstance().getDefaultStartTime();
		} else {
			t = Configuration.getInstance().getDefaultEndTime();
		}
		cal.set(HOUR_OF_DAY, t.getHour());
		cal.set(MINUTE, t.getMin());
		
		GregorianCalendar tempCal = new GregorianCalendar(); // to extract day/month/year info from cal
		token = removeNumSuffixes(token);
		
		Date parsedDate;
		
		// try to parse as full date (day-level)
		parsedDate = dfParse(token, DATE_YMD_DFS);
		if (parsedDate != null) {
			tempCal.setTime(parsedDate);
			cal.set(YEAR, tempCal.get(YEAR));
			cal.set(MONTH, tempCal.get(MONTH));
			cal.set(DAY_OF_MONTH, tempCal.get(DAY_OF_MONTH));
			return cal.getTime();
		}
		
		// try to parse without year
		parsedDate = dfParse(token, DATE_MD_DFS);
		if (parsedDate != null) {
			tempCal.setTime(parsedDate);
			cal.set(MONTH, tempCal.get(MONTH));
			cal.set(DAY_OF_MONTH, tempCal.get(DAY_OF_MONTH));
			return cal.getTime();
		}
		
		// try to parse with only day info
		parsedDate = dfParse(token, DATE_D_DFS);
		if (parsedDate != null) {
			tempCal.setTime(parsedDate);
			cal.set(DAY_OF_MONTH, tempCal.get(DAY_OF_MONTH));
			return cal.getTime();
		}
		// try to parse with only weekday name info
		parsedDate = dfParse(token, DATE_WD_DFS);
		if (parsedDate != null) {
			tempCal.setTime(parsedDate);
			cal.set(DAY_OF_WEEK, tempCal.get(DAY_OF_WEEK));
			return cal.getTime();
		}
		
		throw new ParseException("cannot be parsed only as partial date",-1);
	}
	
	private String removeNumSuffixes (String s) {
		return P_NUM_SUFFIX.matcher(s).replaceAll("$1");
	}
	private Date dfParse (String token, DateFormat[] dfs) {
		for (DateFormat df : dfs) {
			try {
				return df.parse(token);
			} catch (ParseException pe) {
				;
			}
		}
		return null;
	}
	public static void main (String[] args) {
		@SuppressWarnings("resource")
		Scanner sc = new Scanner(System.in);
		PartialDateFormat pdf = new PartialDateFormat();
		while (true) {
			try {
				System.out.println(pdf.parseDate(sc.nextLine(), false));
			} catch (Exception e) {
				System.out.println(e);
			}
		}
	}
}
```
###### src\ui\view\DateFormatter.java
``` java
package ui.view;

import static java.util.Calendar.*;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Scanner;

import parser.temporal.DateParser;

public class DateFormatter {

	public DateFormatter () {
		// TODO Auto-generated constructor stub
	}

	private static final String NULL_DATE = "none";
	private static final DateFormat YEAR_LVL = new SimpleDateFormat("YYYY MMM d (h.mm a)");
	private static final DateFormat MONTH_LVL = new SimpleDateFormat("MMM d EEEE (h.mm a)");
	private static final DateFormat WEEK_LVL = new SimpleDateFormat("MMM d EEEE (h.mm a)");
	private static final DateFormat WEEKDAY_LVL = new SimpleDateFormat("EEEE (h.mm a)");
	private static final DateFormat TMR_LVL = new SimpleDateFormat("'Tomorrow' (h.mm a)");
	private static final DateFormat TODAY_LEVEL = new SimpleDateFormat("'Today' (h.mm a)");
	
	public String formatDate (Date d) {
		final GregorianCalendar now = new GregorianCalendar();
		final GregorianCalendar date = new GregorianCalendar();
		if (d == null) {
			return NULL_DATE;
		}
		date.setTime(d);
		if (now.get(YEAR) != date.get(YEAR)) {
			return YEAR_LVL.format(d);
		}
		if (now.get(MONTH) != date.get(MONTH)) {
			return MONTH_LVL.format(d);
		}
		if (now.get(WEEK_OF_YEAR) != date.get(WEEK_OF_YEAR)) {
			return  WEEK_LVL.format(d);
		}
		if (now.get(DAY_OF_YEAR) + 1 == date.get(DAY_OF_YEAR)) {
			return TMR_LVL.format(d);
		}
		if (now.get(DAY_OF_YEAR) != date.get(DAY_OF_YEAR)) {
			return WEEKDAY_LVL.format(d);
		}
		return TODAY_LEVEL.format(d);
	}
	
	// Overloaded, generates suffix string for number/last digit
	@SuppressWarnings("unused")
	private static String numeralSuffix (String number) {
		assert(number != null);
		final char lastDigit = number.charAt(number.length() - 1);
		return numeralSuffix(lastDigit);
	}
	private static String numeralSuffix (char lastDigit) {
		switch (lastDigit) {
			case '1' :
				return "st";
			case '2' :
				return "nd";
			case '3' :
				return "rd";
			default :
				return "th";
		}
	}
	
	public static void main (String[] args) {
		@SuppressWarnings("resource")
		Scanner sc = new Scanner(System.in);
		DateFormatter df = new DateFormatter();
		DateParser dp = new DateParser();
		while (true) {
			try {
				System.out.println(df.formatDate(dp.parseDate(sc.nextLine(), false)));
			} catch (Exception e) {
				System.out.println(e);
			}
		}
	}
}
```
