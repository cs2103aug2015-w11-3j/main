# A0125546E
###### src\common\Task.java
``` java
    public boolean hasKeyword(String keyword) {
        if (keyword == null) {
            return true;
        } else {
            ArrayList<String> tokens = new ArrayList<>();
            Collections.addAll(tokens, keyword.split(" "));
            return nameHasTokens(tokens);
        }
    }

    private boolean nameHasTokens(List<String> tokens) {
        String nameLowerCase = cName.get().toLowerCase();

        for (String toCompare : tokens) {
            toCompare = toCompare.toLowerCase();
            if (nameLowerCase.contains(toCompare)) {
                return true;
            }
        }
        return false;
    }

    private void updateType() {
        if (cStart.get() == null && cEnd.get() == null) {
            cType.set(Type.FLOATING);
        } else if (cStart.get() != null && cEnd.get() == null) {
            cType.set(Type.NOEND);
        } else if (cStart.get() == null && cEnd.get() != null) {
            cType.set(Type.DEADLINE);
        } else {
            cType.set(Type.EVENT);
        }
    }

    public boolean isWithinDate(Date cFilterDateStart, Date cFilterDateEnd) {
        System.out.println(cFilterDateStart + " " + cFilterDateEnd);
        if (cStart.get() == null && cEnd.get() == null) {
            return false;
        } else if (cStart.get() == null) {
            // No start date, thus check end date is within period
            return isWithinBothDates(cFilterDateStart, cFilterDateEnd, cEnd.get());
        } else if (cEnd.get() == null) {
            // No end date, thus check start date is within period
            return isWithinBothDates(cFilterDateStart, cFilterDateEnd, cStart.get());
        } else {
            // Have both dates
            boolean startIsWithin = isWithinBothDates(cFilterDateStart, cFilterDateEnd, cStart.get());
            boolean endIsWithin = isWithinBothDates(cFilterDateStart, cFilterDateEnd, cEnd.get());

            return startIsWithin && endIsWithin;
        }
    }

    private boolean isWithinBothDates(Date start, Date end, Date toCompare) {
        return toCompare.before(end) && toCompare.after(start);
    }

    public boolean hasDate() {
        return cType.get() != Type.FLOATING;
    }

    public boolean isToday() {
        if (hasDate() == false) {
            return false;
        } else {
            Date compare = getAnyDate();
            assert compare != null;

            Date today = new Date();
            return today.getDate() == compare.getDate();
        }
    }

    /**
     * Obtains the available date that this task contains. Always gets the start
     * date before end
     * 
     * @return
     */
    private Date getAnyDate() {
        Date rtn = cStart.get();
        if (rtn == null) {
            rtn = cEnd.get();
        }
        return rtn;
    }
}
```
###### src\common\TasksBag.java
``` java
package common;

import java.util.Collections;
import java.util.Date;
import java.util.Iterator;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

/**
 * Storage for Tasks Provides adding, deleting and sorting
 */
public class TasksBag implements Iterable<Task> {

    public static enum FilterBy {
        COMPLETE_TASKS, INCOMPLETE_TASKS, NONE, TODAY
    }

    public static enum FilterDateState {
        NONE, AFTER, BEFORE, BETWEEN
    }

    private static final int FLOAT_LIMIT = 3;
    private static final int TASKS_LIMIT = 15;

    private FilterBy cFilterState = FilterBy.INCOMPLETE_TASKS;
    private String cSearchState = null;
    private ObservableList<Task> tasks;
    private Date cFilterDateStart;
    private Date cFilterDateEnd;
    private FilterDateState cDateState = FilterDateState.NONE;

    public FilterDateState getDateState() {
        return cDateState;
    }

    public TasksBag() {
        tasks = FXCollections.observableArrayList();
    }

    public TasksBag(ObservableList<Task> t) {
        tasks = t;
    }

    public Task getTask(int index) {
        assert index < tasks.size() : index;
        return tasks.get(index);
    }

    public Task addTask(Task c) {
        assert c != null : c;

        tasks.add(c);
        return c;
    }

    public void addTask(int index, Task c) {
        assert c != null : c;
        assert index >= 0 : index;

        tasks.add(index, c);
    }

    public int size() {
        return tasks.size();
    }

    public ObservableList<Task> getList() {
        return tasks;
    }

    public void setSortState(FilterBy attribute) {
        assert attribute != null;
        cFilterState = attribute;
    }

    public void setSearchState(String keyword) {
        cSearchState = keyword;
    }

    /**
     * Sort will return a new container as specified by current sorted state
     * Then sort by rev date
     */
    public TasksBag getFiltered() {
        // assert attribute != null;

        ObservableList<Task> newContainer = null;

        switch (cFilterState) {
            /*
             * Not support date filtering case DATE: // Reverse sorting with
             * earliest on top newContainer = TasksBag.copy(tasks);
             * Collections.sort(newContainer, (Task t1, Task t2) ->
             * compareDate(t2, t1)); break;
             */
            case NONE:
                newContainer = FXCollections.observableArrayList();
                for (int i = 0; i < tasks.size(); i++) {
                    Task curTask = tasks.get(i);
                    if (curTask.hasKeyword(cSearchState) && checkDate(curTask)) {
                        newContainer.add(curTask);
                    }
                }
                break;
            case COMPLETE_TASKS:
                newContainer = FXCollections.observableArrayList();
                for (int i = 0; i < tasks.size(); i++) {
                    Task curTask = tasks.get(i);
                    if (curTask.isComplete() && curTask.hasKeyword(cSearchState) && checkDate(curTask)) {
                        newContainer.add(curTask);
                    }
                }
                break;
            case INCOMPLETE_TASKS:
                newContainer = FXCollections.observableArrayList();
                for (int i = 0; i < tasks.size(); i++) {
                    Task curTask = tasks.get(i);
                    if (curTask.isComplete() == false && curTask.hasKeyword(cSearchState) && checkDate(curTask)) {
                        newContainer.add(curTask);
                    }
                }
                break;
            case TODAY:
                newContainer = FXCollections.observableArrayList();
                // count # of floating
                ObservableList<Task> taskFloat = getIncompleteFloatingTasks();
                // count # of dateline/event
                ObservableList<Task> taskNonFloat = getIncompleteDatedTasks();

                int totalCount = taskFloat.size() + taskNonFloat.size();
                if (totalCount <= TASKS_LIMIT) {
                    // take all
                    newContainer.addAll(taskNonFloat);
                    newContainer.addAll(taskFloat);
                } else {

                    if (taskFloat.size() <= FLOAT_LIMIT) {// float count is
                                                          // smaller
                        // fill with float then the rest with nonfloat
                        newContainer.addAll(taskFloat);
                        trimList(taskNonFloat, TASKS_LIMIT - newContainer.size());
                        newContainer.addAll(taskNonFloat);
                    } else {// non float count is smallerF
                        // fill with non float then the rest with floats
                        randomizeList(taskFloat);
                        trimList(taskFloat, FLOAT_LIMIT);
                        newContainer.addAll(taskFloat);
                        trimList(taskNonFloat, TASKS_LIMIT - FLOAT_LIMIT);
                        newContainer.addAll(taskNonFloat);
                    }
                }
                System.out.println("Float: " + taskFloat.size() + " Dated: " + taskNonFloat.size());
                break;
            default:
                assert false;
                break;
        }

        // Sorting by date before returning
        Collections.sort(newContainer, (Task t1, Task t2) -> compareDate(t1, t2));

        // Transfer the current state to the new bag
        // UI uses the sort state to identify current tab
        TasksBag rtnBag = new TasksBag(newContainer);
        rtnBag.setSortState(cFilterState);
        return rtnBag;
    }

    private void randomizeList(ObservableList<Task> list) {
        Collections.shuffle(list);
    }

    /**
     * Reduce the size of the list from the end of the list
     * 
     * @param taskNonFloat
     * @param i
     */
    private void trimList(ObservableList<Task> taskList, int size) {
        // TODO Auto-generated method stub
        // taskList.size();
        taskList.remove(size, taskList.size());
    }

    /**
     * Counts the number of tasks which are incomplete and has at least 1 date
     * 
     * @return
     */
    private ObservableList<Task> getIncompleteDatedTasks() {
        ObservableList<Task> taskList = FXCollections.observableArrayList();

        for (int i = 0; i < tasks.size(); i++) {
            Task curTask = tasks.get(i);
            if (curTask.isComplete() == false && curTask.hasDate() && curTask.isToday() && curTask.hasKeyword(cSearchState)) {
                taskList.add(curTask);
            }
        }
        return taskList;
    }

    /**
     * Counts the number of tasks which are incomplete and has at least 1 date
     * 
     * @return
     */
    private ObservableList<Task> getIncompleteFloatingTasks() {
        ObservableList<Task> taskList = FXCollections.observableArrayList();

        for (int i = 0; i < tasks.size(); i++) {
            Task curTask = tasks.get(i);
            if (curTask.isComplete() == false && curTask.hasDate() == false && curTask.hasKeyword(cSearchState)) {
                taskList.add(curTask);
            }
        }
        return taskList;
    }

    private boolean checkDate(Task curTask) {
        if (cFilterDateEnd == null || cFilterDateStart == null) {
            return true;
        } else {
            return curTask.isWithinDate(cFilterDateStart, cFilterDateEnd);
        }
    }

    public Task removeTask(int index) {
        assert index >= 0 : index;
        assert index <= tasks.size() - 1 : index;

        Task rtnCelebi = tasks.remove(index);
        return rtnCelebi;
    }

    public int removeTask(Task t) {
        assert t != null : "Null task";

        int rtnIndex = tasks.indexOf(t);
        assert rtnIndex >= 0 : rtnIndex;

        tasks.remove(rtnIndex);

        return rtnIndex;
    }

    private int compareDate(Task t1, Task t2) {
        assert t1 != null;
        assert t2 != null;

        Date firstCom, secCom;

        firstCom = getAnyDate(t1);
        secCom = getAnyDate(t2);

        if (firstCom == null && secCom == null) {
            return 0;
        } else if (secCom == null) {
            return -1;
        } else if (firstCom == null) {
            return 1;
        } else {
            return firstCom.compareTo(secCom);
        }
    }

    private Date getAnyDate(Task t1) {
        Date date = null;
        if (t1.getStart() != null) {
            date = t1.getStart();
        } else if (t1.getEnd() != null) {
            date = t1.getEnd();
        }
        return date;
    }

    @Override
    public Iterator<Task> iterator() {
        return tasks.iterator();
    }

    public FilterBy getState() {
        return cFilterState;
    }

    public boolean isEmpty() {
        return tasks.size() == 0;
    }

    public void filterDate(Date start, Date end) {

    }

    public void setFilterDateState(Date start, Date end) {
        cFilterDateStart = start;
        cFilterDateEnd = end;
        updateFilterDateState();
    }

    public void updateFilterDateState() {
        if (cFilterDateStart == null && cFilterDateEnd == null) {
            cDateState = FilterDateState.NONE;
        } else if (cFilterDateStart.equals(Utilities.absBeginningTime())) {
            cDateState = FilterDateState.BEFORE;
        } else if (cFilterDateEnd.equals(Utilities.absEndingTime())) {
            cDateState = FilterDateState.AFTER;
        } else {
            cDateState = FilterDateState.BETWEEN;
        }
    }
    
    public Date getStartDate() {
    	return cFilterDateStart;
    }
    
    public Date getEndDate() {
    	return cFilterDateEnd;
    }
    
    public String getSearchState() {
    	return cSearchState;
    }
}
```
###### src\common\Utilities.java
``` java
    /**
     * Evaluates if start and end dates are valid where end is after start
     * 
     * @param dateStart
     * @param dateEnd
     * @return true if either start or end is null. false if start is after end
     */
    public static final boolean verifyDate(Date dateStart, Date dateEnd) {
        if (dateStart != null && dateEnd != null && dateStart.after(dateEnd)) {
            return false;
        }
        return true;
    }

    public static final String formatString(String s, Object... args) {
        String formatted = String.format(s, args);
        return formatted;

    }

    /**
     * Provides the beginning of time in Unix term
     * 
     * @return the epoch
     */
    public static Date absBeginningTime() {
        return new Date(0);
    }

    /**
     * Provides the ending of time in Unix term 64-bit
     * 
     * @return end date
     */
    public static Date absEndingTime() {
        return new Date(Long.MAX_VALUE);
    }

```
###### src\logic\Action.java
``` java
package logic;

import logic.exceptions.LogicException;

public interface Action {
	public Feedback execute() throws LogicException;
}
```
###### src\logic\ActionInvoker.java
``` java
package logic;

import java.util.ArrayList;

import logic.exceptions.LogicException;
import logic.exceptions.NoRedoActionException;
import logic.exceptions.NoUndoActionException;

/***
 * Invoker part of Command Pattern Deals with keeping track of what actions have
 * been done, Undo/Redo support.
 * 
 * Note the issue when redo-ing on a "switched" filter on the bag. Might cause
 * unintended side effects
 * 
 * @author MonoChrome
 */

public class ActionInvoker {

    private final String MSG_NO_UNDO = "No undoable actions found.";
    private final String MSG_NO_REDO = "No redoable actions found.";
    private ArrayList<Action> cUndo;
    private ArrayList<Action> cRedo;

    public ActionInvoker() {
        cUndo = new ArrayList<Action>();
        cRedo = new ArrayList<Action>();
    }

    public Feedback placeAction(Action act) throws LogicException {
        assert cUndo != null : "Undo arraylist is null";

        // execute may throw exceptions
        Feedback fb = act.execute();

        // If execution passes, then we add into undo queue
        if (act instanceof UndoableAction) {
            cUndo.add(act);

            // Clearing redo list, should not have redo possible
            // if new actions executed
            cRedo.clear();
        }
        return fb;
    }

    public Feedback undoAction() throws NoUndoActionException {
        assert cUndo != null : "Undo arraylist is null";

        if (cUndo.size() == 0) {
            throw new NoUndoActionException(MSG_NO_UNDO);
        }

        UndoableAction undoAction = (UndoableAction) cUndo.remove(cUndo.size() - 1);
        cRedo.add(undoAction);

        return undoAction.undo();
    }

    public Feedback redoAction() throws NoRedoActionException, LogicException {
        assert cRedo != null : "Redo arraylist is null";

        if (cRedo.size() == 0) {
            throw new NoRedoActionException(MSG_NO_REDO);
        }

        UndoableAction redoAction = (UndoableAction) cRedo.remove(cRedo.size() - 1);
        cUndo.add(redoAction);

        return redoAction.redo();
    }
}
```
###### src\logic\AddAction.java
``` java
package logic;

import java.util.Date;

import common.Task;
import common.TasksBag;
import common.Utilities;
import logic.exceptions.IntegrityCommandException;
import logic.exceptions.LogicException;
import parser.Command;
import storage.StorageInterface;

/**
 * Adds tasks into internal bag Undo removes the task
 */
public class AddAction implements UndoableAction {

    private static final String USR_MSG_ADD_OK = "Added %1$s!";
    private static final String USR_MSG_ADD_UNDO = "Undo adding %1$s!";
    private static final String USR_MSG_ADD_DATE_ERROR = "Failed to add! Start date is after end date!";

    private Command cCommand;
    private TasksBag cBag;
    private StorageInterface cStore;
    private Task cWhichTask;

    public AddAction(Command command, TasksBag bag, StorageInterface stor) throws IntegrityCommandException {
        cCommand = command;
        cBag = bag;
        cStore = stor;

        String name = cCommand.getText();
        Date startDate = cCommand.getStart();
        Date endDate = cCommand.getEnd();

        boolean isValidDate = Utilities.verifyDate(startDate, endDate);
        if (isValidDate) {
            cWhichTask = new Task(name, startDate, endDate);
        } else {
            throw new IntegrityCommandException(USR_MSG_ADD_DATE_ERROR);
        }

    }

    @Override
    public Feedback execute() throws LogicException {
        String formattedString;
        Feedback fb;

        cBag.addTask(cWhichTask);
        cStore.save(cWhichTask);

        formattedString = Utilities.formatString(USR_MSG_ADD_OK, cWhichTask.getName());
        fb = new Feedback(cCommand, cBag, formattedString);

        return fb;
    }

    @Override
    public Feedback undo() {
        assert cWhichTask != null;

        cStore.delete(cWhichTask);
        cBag.removeTask(cWhichTask);
        String formatted = Utilities.formatString(USR_MSG_ADD_UNDO, cWhichTask.getName());
        return new Feedback(cCommand, cBag, formatted);
    }

    @Override
    public Feedback redo() throws LogicException {
        return execute();
    }
}
```
###### src\logic\DeleteAction.java
``` java
package logic;

import java.util.logging.Logger;

import common.Log;
import common.Task;
import common.TasksBag;
import common.Utilities;
import logic.exceptions.IntegrityCommandException;
import logic.exceptions.LogicException;
import parser.Command;
import storage.StorageInterface;

/***
 * Note that due to execute being called again when redo-ing. The task to be
 * deleted has to be decided at INIT/Constructor time. Not at execution time.
 */
public class DeleteAction implements UndoableAction {

    private static final String USR_MSG_DELETE_OOB = "Provided index not on list.";
    private static final String USR_MSG_DELETE_OK = "Removed %1$s!";
    private static final String USR_MSG_DELETE_UNDO = "Undoing delete %1$s";

    private Command cCommand;
    private TasksBag cCurBag;
    private TasksBag cIntBag;
    private StorageInterface cStore;
    private Task cWhichTask; // The task to be modified
    private boolean isSuccessful;
    private int cPosition; // Position of internal bag
    Logger log;

    /**
     * Returns a Delete Action object in the internal bag. References the curBag
     * to get the actual internalbag task
     *
     * @param command
     *            Command of the action
     * @param curBag
     *            Current bag status internalBag Internal bag
     * @param stor
     *            Storage pointer
     * @throws IntegrityCommandException
     *             When provided with an index that will access OOB values
     */
    public DeleteAction(Command command, TasksBag internalBag, StorageInterface stor) throws IntegrityCommandException {
        assert internalBag != null;
        assert stor != null;
        assert command != null;

        cCommand = command;
        cCurBag = internalBag.getFiltered();
        cIntBag = internalBag;
        cStore = stor;
        isSuccessful = false;
        log = Logger.getLogger("DeleteAction");

        // Find the offending command and lock it at init time
        int UID = cCommand.getTaskUID();

        if (UID <= 0) {
            throw new IntegrityCommandException(USR_MSG_DELETE_OOB);
        }

        if (UID > cCurBag.size()) {
            throw new IntegrityCommandException(USR_MSG_DELETE_OOB);
        }

        // UID - 1 to get array index
        UID -= 1;

        cWhichTask = cCurBag.getTask(UID);
    }

    /**
     * Attempts to execute the action Returns Feedback of the action
     * 
     * @throws IntegrityCommandException
     *             If deleting out of bound
     */
    @Override
    public Feedback execute() throws LogicException {
        String formattedString;
        Feedback fb;

        cPosition = cIntBag.removeTask(cWhichTask);
        cStore.delete(cWhichTask);

        formattedString = Utilities.formatString(USR_MSG_DELETE_OK, cWhichTask.getName());
        fb = new Feedback(cCommand, cIntBag, formattedString);

        return fb;
    }

    /**
     * Insert task back into internal bag at removed position Saves task back
     * into storage
     */
    @Override
    public Feedback undo() {
        String formattedString;
        formattedString = Utilities.formatString(USR_MSG_DELETE_UNDO, cWhichTask.getName());

        cIntBag.addTask(cPosition, cWhichTask);
        cStore.save(cWhichTask);

        return new Feedback(cCommand, cIntBag, formattedString);
    }

    /**
     * Remove task object from bag Deletes task at storage
     */
    @Override
    public Feedback redo() throws LogicException {
        return execute();
    }
}
```
###### src\logic\exceptions\ActionException.java
``` java
package logic.exceptions;

public class ActionException extends LogicException {
    
    private static final long serialVersionUID = 663428951026655012L;

    public ActionException(String msg) {
        super(msg);
    }

}
```
###### src\logic\exceptions\AlreadyMarkedException.java
``` java
package logic.exceptions;

public class AlreadyMarkedException extends LogicException {

    private static final long serialVersionUID = 7605084398231648593L;

    public AlreadyMarkedException(String msg) {
        super(msg);
    }

}
```
###### src\logic\exceptions\AlreadyUnmarkedException.java
``` java
package logic.exceptions;

public class AlreadyUnmarkedException extends LogicException {

    private static final long serialVersionUID = 4423335997573387768L;

    public AlreadyUnmarkedException(String msg) {
        super(msg);
    }

}
```
###### src\logic\exceptions\IllegalAccessCommandException.java
``` java
package logic.exceptions;

public class IllegalAccessCommandException extends LogicException {
    private static final long serialVersionUID = -1205053410414852622L;

    public IllegalAccessCommandException(String msg) {
        super(msg);
    }

}
```
###### src\logic\exceptions\IntegrityCommandException.java
``` java
package logic.exceptions;

public class IntegrityCommandException extends LogicException {

    private static final long serialVersionUID = -7658067372077628329L;

    public IntegrityCommandException(String msg) {
        super(msg);
    }
}
```
###### src\logic\exceptions\InvalidDateException.java
``` java
package logic.exceptions;

public class InvalidDateException extends LogicException {

    private static final long serialVersionUID = -7002613567304746646L;

    public InvalidDateException(String msg) {
        super(msg);
        // TODO Auto-generated constructor stub
    }

}
```
###### src\logic\exceptions\LogicException.java
``` java
package logic.exceptions;

public class LogicException extends Exception {

	private static final long serialVersionUID = 8103789619642292889L;
	public final String cMsg;

	public LogicException(String msg){
		cMsg = msg;
	}
}
```
###### src\logic\exceptions\NoRedoActionException.java
``` java
package logic.exceptions;

public class NoRedoActionException extends ActionException {

    private static final long serialVersionUID = -5029418244543740195L;

    public NoRedoActionException(String msg) {
        super(msg);
    }

}
```
###### src\logic\exceptions\NoUndoActionException.java
``` java
package logic.exceptions;

public class NoUndoActionException extends ActionException {

    private static final long serialVersionUID = -6305570505075435759L;

    public NoUndoActionException(String msg) {
        super(msg);
    }
}
```
###### src\logic\exceptions\UnknownCommandException.java
``` java
package logic.exceptions;

public class UnknownCommandException extends LogicException {

    private static final long serialVersionUID = -7836866875248053818L;

    public UnknownCommandException(String msg) {
        super(msg);
    }

}
```
###### src\logic\Feedback.java
``` java
package logic;

import common.TasksBag;
import parser.Command;

/*
 * Wrapper class to contain Command type and 
 * CelebiBag for UI
 */
public class Feedback {
    private final TasksBag cBag;
    private final Command cCommand;
    private String cMsg;

    public Feedback(Command comd, TasksBag bag) {
        cBag = bag;
        cCommand = comd;
    }

    public Feedback(Command comd, TasksBag bag, String msg) {
        this(comd, bag);
        cMsg = msg;
    }

    /**
     * Provides the current sorted state of bag for UI
     * 
     * @return sorted state of bag
     */
    public TasksBag getcBag() {
        return cBag.getFiltered();
    }

    public Command getCommand() {
        return cCommand;
    }

    public String getMsg() {
        return cMsg;
    }

    public void setMsg(String msg) {
        cMsg = msg;
    }

}
```
###### src\logic\FilterDateAction.java
``` java
package logic;

import java.util.Date;

import common.TasksBag;
import common.Utilities;
import logic.exceptions.LogicException;
import parser.Command;

public class FilterDateAction implements Action {

    private static final String USR_MSG_FILTER_AFTER_DATE = "Filtering dates after %1$s";
    private static final String USR_MSG_FILTER_BEFORE_DATE = "Filtering dates before %1$s";
    private static final String USR_MSG_FILTER_BETWEEN_DATE = "Filtering dates between %1$s and %2$s";

    private Command cCommand;
    private TasksBag cBag;
    private Date cStart;
    private Date cEnd;

    public FilterDateAction(Command command, TasksBag internalBag) throws LogicException {
        cCommand = command;
        cBag = internalBag;
        cStart = cCommand.getStart();
        cEnd = cCommand.getEnd();
    }

    @Override
    public Feedback execute() throws LogicException {
        Feedback fb;

        cBag.setFilterDateState(cStart, cEnd);
        TasksBag.FilterDateState dState = cBag.getDateState();

        fb = new Feedback(cCommand, cBag, getFeedbackText(dState));
        return fb;
    }

    private String getFeedbackText(TasksBag.FilterDateState state) {
        String rtn = "Filtering date after " + cStart + " to " + cEnd;
        switch (state) {
            case AFTER:
                rtn = Utilities.formatString(USR_MSG_FILTER_AFTER_DATE, cStart);
                break;

            case BEFORE:
                rtn = Utilities.formatString(USR_MSG_FILTER_BEFORE_DATE, cEnd);
                break;
            case BETWEEN:
                rtn = Utilities.formatString(USR_MSG_FILTER_BETWEEN_DATE, cStart, cEnd);
                break;
            default:
                break;
        }
        return rtn;
    }

}
```
###### src\logic\HelpAction.java
``` java
package logic;

import common.TasksBag;
import logic.exceptions.LogicException;
import parser.Command;
import parser.Command.Type;
import parser.HelpStrings;

public class HelpAction implements Action {

    private static final String USR_MSG_HELP_INVALID = "No help available for this command";
    private Command cCommand;
    private TasksBag cBag;
    
    public HelpAction(Command rtnCmd, TasksBag bag) {
        cCommand = rtnCmd;
        cBag = bag;
    }

    @Override
    public Feedback execute() throws LogicException {
        String msg = "";
        Feedback fb;
        Type cmdType = cCommand.getHelpCmdType();
        
        // General help command requested by user
        if(cmdType == null){
            msg = buildString(HelpStrings.HELP_LIST_ALL_CMDS);
        }else {
            msg = generateHelpString();
        }
        
        fb = new Feedback(cCommand,cBag, msg);
        return fb;
    }

    private String generateHelpString() {
        String msg;
        switch(cCommand.getHelpCmdType()){
            case ADD:
                msg = buildString(HelpStrings.HELP_FORMAT_ADD);
                break;
            case DELETE:
                msg = buildString(HelpStrings.HELP_FORMAT_DEL);
                break;
            case FILTER_DATE:
                msg = buildString(HelpStrings.HELP_FORMAT_FILTER);
                break;
            case HELP:
                msg = buildString(HelpStrings.HELP_FORMAT_HELP);
                break;
            case MARK:
                msg = buildString(HelpStrings.HELP_FORMAT_MARK);
                break;
            case MOVE:
                msg = buildString(HelpStrings.HELP_FORMAT_MOVE);
                break;
            case QUIT:
                msg = buildString(HelpStrings.HELP_FORMAT_QUIT);
                break;
            case REDO:
                msg = buildString(HelpStrings.HELP_FORMAT_REDO);
                break;
            case SEARCH:
                msg = buildString(HelpStrings.HELP_FORMAT_SEARCH);
                break;
            case SHOW_COMPLETE:
                msg = buildString(HelpStrings.HELP_FORMAT_SHOW);
                break;
            case SHOW_DEFAULT:
                msg = buildString(HelpStrings.HELP_FORMAT_SHOW);
                break;
            case SHOW_INCOMPLETE:
                msg = buildString(HelpStrings.HELP_FORMAT_SHOW);
                break;
            case UNDO:
                msg = buildString(HelpStrings.HELP_FORMAT_UNDO);
                break;
            case UNMARK:
                msg = buildString(HelpStrings.HELP_FORMAT_UNMARK);
                break;
            case show_temp:
                msg = buildString(HelpStrings.HELP_FORMAT_HELP_TEMP);
                break;
            case UPDATE:
                msg = buildString(HelpStrings.HELP_FORMAT_UPD);
                break;
            case INVALID:       // Fallthrough
            default:
                msg = buildString(USR_MSG_HELP_INVALID);
                break;
            
        }
        return msg;
    }

    private String buildString(String s){
        return "Enter " + s;
    }
}
```
###### src\logic\Logic.java
``` java
package logic;

import java.util.logging.Logger;

import common.Task;
import logic.exceptions.IntegrityCommandException;
import logic.exceptions.LogicException;
import logic.exceptions.UnknownCommandException;
import common.TasksBag;
import common.TasksBag.FilterBy;
import parser.Command;
import parser.Command.Type;
import parser.Parser;
import parser.ParserInterface;
import storage.Storage;
import storage.StorageInterface;


public class Logic implements LogicInterface {

    private static final String USR_MSG_UNKNOWN_COMMAND = "I couldn't understand you... (>.<)";

    // The default view when UI first query the bag
    private static final FilterBy DEFAULT_UI_VIEW = TasksBag.FilterBy.TODAY;

    private StorageInterface cStorage;
    private ParserInterface cParser;
    private TasksBag cInternalBag;
    private ActionInvoker cInvoker;
    private Logger log;

    public Logic() {
        cInternalBag = new TasksBag();
        cInvoker = new ActionInvoker();
        log = Logger.getLogger("Logic");
    }

    @Override
    public void init() {

        cStorage = new Storage();
        cStorage.init();
        cParser = Parser.getParser();
        cParser.init();

        System.out.println("Logic Init complete");
    }

    /**
     * Passes string param to parser then evaluates the command type
     * 
     * @exception IntegrityCommandException
     *                When given input violates validity
     * @exception InvalidCommandException
     *                When given input cannot be understood
     * @param userString
     *            string value entered by user
     */
    @Override
    public Feedback executeCommand(String userString) throws LogicException {
        Command rtnCmd = cParser.parseCommand(userString);
        if(userString.equals("show today")){
            return cInvoker.placeAction(new SortAction(Parser.getParser().makeShow(Type.SHOW_DEFAULT) , cInternalBag, TasksBag.FilterBy.TODAY));
        }
        log.info("executing " + userString);
        return executeParsed(rtnCmd);
    }

    private Feedback executeParsed(Command rtnCmd) throws LogicException {
        
        Feedback fb;
        switch (rtnCmd.getCmdType()) {
            case ADD:
                fb = cInvoker.placeAction(new AddAction(rtnCmd, cInternalBag, cStorage));
                break;
            case DELETE:
                fb = cInvoker.placeAction(new DeleteAction(rtnCmd, cInternalBag, cStorage));
                break;
            case SHOW_COMPLETE:
                fb = cInvoker.placeAction(new SortAction(rtnCmd, cInternalBag, TasksBag.FilterBy.COMPLETE_TASKS));
                break;
            case UPDATE:
                fb = cInvoker.placeAction(new UpdateAction(rtnCmd, cInternalBag, cStorage));
                break;
            case SHOW_INCOMPLETE:
                fb = cInvoker.placeAction(new SortAction(rtnCmd, cInternalBag, TasksBag.FilterBy.INCOMPLETE_TASKS));
                break;
            case MARK:
                fb = cInvoker.placeAction(new MarkAction(rtnCmd, cInternalBag, cStorage));
                break;
            case UNMARK:
                fb = cInvoker.placeAction(new UnmarkAction(rtnCmd, cInternalBag, cStorage));
                break;
            case UNDO:
                fb = cInvoker.undoAction();
                break;
            case REDO:
                fb = cInvoker.redoAction();
                break;
            case FILTER_DATE:
                fb = cInvoker.placeAction(new FilterDateAction(rtnCmd, cInternalBag));
                break;
            case MOVE:
                fb = cInvoker.placeAction(new MoveFileAction(rtnCmd, cInternalBag, cStorage));
                break;
            case QUIT:
                log.info("recevied quit");
                fb = new Feedback(rtnCmd, null);
                break;
            case SEARCH:
            	fb = cInvoker.placeAction(new SearchAction(rtnCmd, cInternalBag));
                break;
            case INVALID:
                log.info("recevied invalid type");
                throw new UnknownCommandException(USR_MSG_UNKNOWN_COMMAND);
            case SHOW_DEFAULT:
                fb = cInvoker.placeAction(new SortAction(rtnCmd, cInternalBag, DEFAULT_UI_VIEW));
                break;
            case HELP:
                fb = cInvoker.placeAction(new HelpAction(rtnCmd, cInternalBag));
                break;
            default:
                assert false : rtnCmd.getCmdType();
                fb = new Feedback(rtnCmd, cInternalBag);
                break;
        }
        return fb;
    }



    @Override
    public boolean initData(String s) {

        boolean rtnVal = cStorage.load(s, cInternalBag);
        return rtnVal;
    }

    @Override
    public TasksBag getTaskBag() {
        return cInternalBag;
    }

    public void setStorage(StorageInterface storageStub) {
        System.out.println("Stub added for storage");
        cStorage = storageStub;
    }

    public void setParser(ParserInterface parserStub) {
        System.out.println("STUB ADDED FOR PARSER");
        cParser = parserStub;
    }

    @Override
    public TasksBag getDefaultBag() {
        cInternalBag.setSortState(DEFAULT_UI_VIEW);
        return cInternalBag.getFiltered();
    }

}
```
###### src\logic\LogicInterface.java
``` java
package logic;

import common.TasksBag;
import logic.exceptions.LogicException;

public interface LogicInterface {

    public void init();

    public boolean initData(String s); // Returns true if successfully init data

    public Feedback executeCommand(String cmd) throws LogicException;

    public TasksBag getTaskBag();

    public TasksBag getDefaultBag();

}
```
###### src\logic\LogicTest.java
``` java
package logic;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import common.Task;
import common.TasksBag;
import logic.exceptions.AlreadyMarkedException;
import logic.exceptions.AlreadyUnmarkedException;
import logic.exceptions.IllegalAccessCommandException;
import logic.exceptions.IntegrityCommandException;
import logic.exceptions.LogicException;
import logic.exceptions.NoRedoActionException;
import logic.exceptions.NoUndoActionException;
import logic.exceptions.UnknownCommandException;

public class LogicTest {

    static Logic logic;

    @Before
    public void initTest() {
        init();
    }

    @Test
    public void testFullCoverage() {

        // Logic.java
        testFailException("khasd", UnknownCommandException.class);
        testFailException("undo", NoUndoActionException.class);
        testFailException("redo", NoRedoActionException.class);
        testFailException("remove 1", IllegalAccessCommandException.class);
        testFailException("remove 0", IllegalAccessCommandException.class);

        // AddAction.java
        testPass("add task 1");
        testPass("add task 2");
        testPass("undo");
        testPass("redo");

        // DeleteAction.java
        testFailException("delete 0", IllegalAccessCommandException.class);
        testFailException("delete 3", IllegalAccessCommandException.class);
        testPass("delete 1");
        testPass("undo");
        testPass("redo");

        // UpdateAction.java
        testFailException("update 0 name hello", IllegalAccessCommandException.class);
        testFailException("update 3 name hello", IllegalAccessCommandException.class);
        testPass("update 1 name hello");
        testFailException("update 1 start hello", UnknownCommandException.class);
        testPass("update 1 start 2015-10-10 15:00");
        testPass("update 1 end now");

        // Show
        testPass("show");
        testPass("show done");
        testFailException("delete 1", IllegalAccessCommandException.class);
        testPass("show");

        // Mark/Unmark
        testFailException("unmark 1", AlreadyUnmarkedException.class);
        testPass("mark 1");
        testFailException("mark 0", IllegalAccessCommandException.class);

        // Search
        testPass("search hello");
        testPass("show");

        // filter
        testPass("filter from now to tmr");
    }

    @Test
    public void testAdd() {
        TasksBag temp;
        Task tempTask;

        testPass("add name");

        temp = logic.getTaskBag();
        tempTask = temp.getTask(0);

        Assert.assertEquals(1, temp.size());
        Assert.assertEquals("name", tempTask.getName());

    }

    @Test
    public void testDelete() {
        // Boundary for fail. Empty entry
        testFailException("d 0", IntegrityCommandException.class);

        testPass("add one");
        // Boundary for fail. 0 and 2 with size 1
        testFailException("d 0", IntegrityCommandException.class);
        testFailException("d 2", IntegrityCommandException.class);
    }

    @Test
    public void testMark() {
        Task t;
        // Boundary for 0 entry but trying to mark
        testFailException("mark 0", IntegrityCommandException.class);

        testPass("add one");
        testPass("mark 1");

        t = logic.getTaskBag().getTask(0);
        Assert.assertEquals(true, t.isComplete());

        // fail test under INCOMPLETE(default) filter of tasksbag
        testFailException("mark 1", IntegrityCommandException.class);

        logic.getTaskBag().setSortState(TasksBag.FilterBy.COMPLETE_TASKS);

        testFailException("mark 1", AlreadyMarkedException.class);

        // Can access task bag due to COMPLETE filter now
        t = logic.getTaskBag().getTask(0);
        Assert.assertEquals(true, t.isComplete());
    }

    @Test
    public void testUnmark() {
        // Boundary for 0 entry but trying to unmark
        Task t;
        testFailException("unmark 0", IntegrityCommandException.class);

        testPass("add one");
        testFailException("unmark 1", AlreadyUnmarkedException.class);

        t = logic.getTaskBag().getTask(0);
        Assert.assertEquals(false, t.isComplete());

        // Unmark twice onto same object. Should throw exception
        testFailException("unmark 1", AlreadyUnmarkedException.class);

        t = logic.getTaskBag().getTask(0);
        Assert.assertEquals(false, t.isComplete());

        // Mark and unmarking
        testPass("mark 1");
        testPass("show done");
        testPass("unmark 1");
        Assert.assertEquals(false, t.isComplete());
    }

    @Test
    public void testTaskSearchKeyword() {
        Task k = new Task("LowerCase UpperCase", null, null);

        // Half match case mixcase
        Assert.assertEquals(true, k.hasKeyword("LowerCase"));
        // Full match case mixrcase
        Assert.assertEquals(true, k.hasKeyword("lowerCase uppErCase"));
        // substring case
        Assert.assertEquals(true, k.hasKeyword("er"));
        // non substring
        Assert.assertEquals(false, k.hasKeyword("ber"));
        // Empty string
        Assert.assertEquals(true, k.hasKeyword(""));
        // Null string
        Assert.assertEquals(true, k.hasKeyword(null));

    }

    private void testPass(String passCommand) {
        try {
            logic.executeCommand(passCommand);
        } catch (LogicException e) {
            Assert.fail("Should not thrown Exception for: " + passCommand + e.toString());
        }
    }

    private void testFailException(String failCommand, Class<? extends LogicException> whatException) {
        try {
            logic.executeCommand(failCommand);
        } catch (LogicException e) {
            e.getClass().equals(whatException);
            return;
        }
        Assert.fail("Should have thrown " + whatException.getName() + " for: " + failCommand);
    }

    /*
     * 
     * private void testFailAlreadyMarked(String failCommand) { try {
     * logic.executeCommand(failCommand); } catch (AlreadyMarkedException e) {
     * return; } catch (LogicException e) { Assert.fail(
     * "Should have thrown Already Marked Exception for: " + failCommand); }
     * Assert.fail("Should have thrown Already Marked Exception for: " +
     * failCommand); }
     * 
     * private void testFailAlreadyUnmarked(String failCommand) { try {
     * logic.executeCommand(failCommand); } catch (AlreadyUnmarkedException e) {
     * return; } catch (LogicException e) { Assert.fail(
     * "Should have thrown Already Unmarked Exception for: " + failCommand); }
     * Assert.fail("Should have thrown Already Unmarked Exception for: " +
     * failCommand); }
     * 
     * // Will return if it actually fails the integrity test private void
     * testFailIntegrity(String failCommand) { try {
     * logic.executeCommand(failCommand); } catch (IntegrityCommandException e)
     * { return; } catch (LogicException e) { Assert.fail(
     * "Should have thrown Integrity Exception for: " + failCommand); }
     * Assert.fail("Should have thrown Integrity Exception for: " +
     * failCommand); }
     */

    private void init() {
        logic = new Logic();
        logic.init();

        logic.setStorage(new StorageStub());
        // logic.setParser(new ParserStub());
    }

}
```
###### src\logic\MarkAction.java
``` java
package logic;

import java.util.logging.Logger;

import common.Task;
import common.TasksBag;
import common.Utilities;
import logic.exceptions.AlreadyMarkedException;
import logic.exceptions.IntegrityCommandException;
import logic.exceptions.LogicException;
import parser.Command;
import storage.StorageInterface;

public class MarkAction implements UndoableAction {

    private static final String USR_MSG_INDEX_ERR = "Provided index not on list.";
    private static final String USR_MSG_MARK_OK = "Marked %1$s!";
    private static final String USR_MSG_MARK_FAIL = "Already marked %1$s!";
    private static final String USR_MSG_MARK_UNDO = "Undo mark %1$s!";
    
    private Command cCommand;
    private TasksBag cCurBag;    
    private TasksBag cIntBag;
    private StorageInterface cStore;
    private Task cWhichTask;
    
    private Logger log;
    
    public MarkAction(Command command, TasksBag internalBag, StorageInterface stor) throws IntegrityCommandException {
        
        cCommand = command;
        cCurBag = internalBag.getFiltered();
        cIntBag = internalBag;
        cStore = stor;
        log = Logger.getLogger("MarkAction");
        
        int UID = cCommand.getTaskUID();

        if (UID <= 0) {
            throw new IntegrityCommandException(USR_MSG_INDEX_ERR);
        }

        if (UID > cCurBag.size()) {
            log.warning("Exceeded size" + UID + " " + cCurBag.size());
            throw new IntegrityCommandException(USR_MSG_INDEX_ERR);
        }

        // UID - 1 to get  array index
        UID -= 1;
        
        cWhichTask = cCurBag.getTask(UID);
    }

    @Override
    public Feedback execute() throws LogicException {
        String formattedString;
        // Should not mark again if it is already marked.
        // Does not go into undo queue if already marked.
        if(cWhichTask.isComplete()){ 
            formattedString = Utilities.formatString(USR_MSG_MARK_FAIL, cWhichTask.getName());
            throw new AlreadyMarkedException(formattedString);
        } else { 
            cWhichTask.setComplete(true);
            cStore.save(cWhichTask);
        }
        
        formattedString =  Utilities.formatString(USR_MSG_MARK_OK, cWhichTask.getName());
        Feedback fb = new Feedback(cCommand, cIntBag, formattedString);

        return fb;
    }

    @Override
    public Feedback undo() {
        assert cWhichTask != null;

        cWhichTask.setComplete(false);
        cStore.save(cWhichTask);
        
        String formattedString =  Utilities.formatString(USR_MSG_MARK_UNDO, cWhichTask.getName());
        return new Feedback(cCommand, cIntBag, formattedString);
    }

    @Override
    public Feedback redo() throws LogicException {
        return execute();
    }
}
```
###### src\logic\SearchAction.java
``` java
package logic;

import common.TasksBag;
import common.Utilities;
import logic.exceptions.LogicException;
import parser.Command;

public class SearchAction implements Action {
    private static final String USR_MSG_SEARCH_COMPLETE = "Search for %1$s";

    private Command cCommand;
    private TasksBag cBag;
    private String cKeyword;

    public SearchAction(Command command, TasksBag internalBag) throws LogicException {
        cCommand = command;
        cBag = internalBag;
        cKeyword = command.getText();
    }

    @Override
    public Feedback execute() throws LogicException {
        String formattedString;

        cBag.setSearchState(cKeyword);
        formattedString = Utilities.formatString(USR_MSG_SEARCH_COMPLETE, cKeyword);

        return new Feedback(cCommand, cBag, formattedString);
    }

}
```
###### src\logic\SortAction.java
``` java
package logic;

import common.TasksBag;
import common.TasksBag.FilterBy;
import logic.exceptions.IntegrityCommandException;
import logic.exceptions.LogicException;
import parser.Command;

/**
 * Changes the state of the internal taskbags to given sort state Undo sets the
 * internal bag state to previous state
 */
public class SortAction implements Action {
    private static final String USR_MSG_SORT_COMPLETE = "Switching view to completed tasks";
    private static final String USR_MSG_SORT_INCOMPLETE = "Switching view to incompleted tasks";
    private static final String USR_MSG_SORT_TODAY = "Switching view to today tasks";

    private Command cCommand;
    private TasksBag cBag;
    private FilterBy cSortBy;

    public SortAction(Command command, TasksBag internalBag, FilterBy sortBy) throws LogicException {
        cCommand = command;
        cBag = internalBag;
        cSortBy = sortBy;
    }

    @Override
    public Feedback execute() throws LogicException {
        String msg = "";
        switch (cSortBy) {
            case COMPLETE_TASKS:
                msg = USR_MSG_SORT_COMPLETE;
                cBag.setSortState(FilterBy.COMPLETE_TASKS);
                break;
            case INCOMPLETE_TASKS:
                msg = USR_MSG_SORT_INCOMPLETE;
                cBag.setSortState(FilterBy.INCOMPLETE_TASKS);
                break;
            case TODAY:
                msg = USR_MSG_SORT_TODAY;
                cBag.setSortState(FilterBy.TODAY);
                break;
            case NONE:
                assert false;
                break;
            default:
                assert false;
                break;

        }

        // both search string and filter date will be reset
        cBag.setSearchState(null);
        cBag.setFilterDateState(null, null);
        return new Feedback(cCommand, cBag, msg);
    }

}
```
###### src\logic\StorageStub.java
``` java
package logic;

import common.Task;
import common.TasksBag;
import storage.StorageInterface;

public class StorageStub implements StorageInterface {

    @Override
    public void init() {
        // TODO Auto-generated method stub

    }

    @Override
    public boolean load(String s, TasksBag c) {
        // TODO Auto-generated method stub
        return true;
    }

    @Override
    public boolean save(Task c) {
        // TODO Auto-generated method stub
        return true;
    }

    @Override
    public boolean delete(Task c) {
        // TODO Auto-generated method stub
        return true;
    }

    @Override
    public boolean moveFileTo(String destination) {
        // TODO Auto-generated method stub
        return true;
    }

}
```
###### src\logic\UndoableAction.java
``` java
package logic;

import logic.exceptions.LogicException;

public interface UndoableAction extends Action {
    
    public Feedback undo();

    public Feedback redo() throws LogicException;
}
```
###### src\logic\UnmarkAction.java
``` java
package logic;

import java.util.logging.Logger;

import common.Task;
import common.TasksBag;
import common.Utilities;
import logic.exceptions.AlreadyUnmarkedException;
import logic.exceptions.IntegrityCommandException;
import logic.exceptions.LogicException;
import parser.Command;
import storage.StorageInterface;


public class UnmarkAction implements UndoableAction {

    private static final String USR_MSG_INDEX_ERR = "Provided index not on list.";
    private static final String USR_MSG_UNMARK_OK = "Unmarked %1$s!";
    private static final String USR_MSG_UNMARK_FAIL = "Already unmarked %1$s!";
    private static final String USR_MSG_UNMARK_UNDO = "Undo unmarked %1$s!";

    private Command cCommand;
    private TasksBag cCurBag;
    private TasksBag cIntBag;
    private StorageInterface cStore;
    private Task cWhichTask;

    private Logger log;

    public UnmarkAction(Command command, TasksBag internalBag, StorageInterface stor) throws IntegrityCommandException {
        cCommand = command;
        cCurBag = internalBag.getFiltered();
        cIntBag = internalBag;
        cStore = stor;
        log = Logger.getLogger("UnmarkAction");

        int UID = cCommand.getTaskUID();

        if (UID <= 0) {
            throw new IntegrityCommandException(USR_MSG_INDEX_ERR);
        }

        if (UID > cCurBag.size()) {
            log.warning("Exceeded size" + UID + " " + cCurBag.size());
            throw new IntegrityCommandException(USR_MSG_INDEX_ERR);
        }

        // UID - 1 to get array index
        UID -= 1;

        cWhichTask = cCurBag.getTask(UID);
    }

    @Override
    public Feedback execute() throws LogicException {
        String formattedString;
        
        // Should not unmark again if it is already unmarked.
        // Does not go into undo queue if already unmarked.
        if (cWhichTask.isComplete() == false) {
            formattedString = Utilities.formatString(USR_MSG_UNMARK_FAIL, cWhichTask.getName());
            throw new AlreadyUnmarkedException(formattedString);
        } else {
            cWhichTask.setComplete(false);
            cStore.save(cWhichTask);
        }
        
        formattedString = Utilities.formatString(USR_MSG_UNMARK_OK, cWhichTask.getName());
        Feedback fb = new Feedback(cCommand, cIntBag, formattedString);

        return fb;
    }

    @Override
    public Feedback undo() {
        assert cWhichTask != null;

        cWhichTask.setComplete(true);
        cStore.save(cWhichTask);
        
        String formattedString = Utilities.formatString(USR_MSG_UNMARK_UNDO, cWhichTask.getName());
        return new Feedback(cCommand, cIntBag, formattedString);
    }

    @Override
    public Feedback redo() throws LogicException {
        return execute();
    }
}
```
###### src\logic\UpdateAction.java
``` java
package logic;

import common.Task;
import common.TasksBag;
import common.Utilities;
import logic.exceptions.IntegrityCommandException;
import logic.exceptions.InvalidDateException;
import logic.exceptions.LogicException;
import parser.Command;
import storage.StorageInterface;

public class UpdateAction implements UndoableAction {
    private static final String USR_MSG_UPDATE_OOB = "Provided index not on list.";
    private static final String USR_MSG_UPDATE_STARTDATE_OK = "Updated start date of %1$s!";
    private static final String USR_MSG_UPDATE_STARTDATE_INVALID = "Failed to update! Start date is earlier than of end date!";
    private static final String USR_MSG_UPDATE_ENDDATE_OK = "Updated end date of %1$s!";
    private static final String USR_MSG_UPDATE_ENDDATE_INVALID = "Failed to update! End date is earlier than of start date!";
    private static final String USR_MSG_UPDATE_NAME_OK = "Updated name of %1$s!";
    private static final String USR_MSG_UPDATE_UNDO = "Undo update %1$s!";

    private Command cCommand;
    private TasksBag cCurBag;
    private TasksBag cIntBag;
    private StorageInterface cStore;
    private Task cWhichTask;
    private Task cOldTask;
    
    public UpdateAction(Command command, TasksBag bag, StorageInterface stor) throws LogicException {
        cCommand = command;
        cCurBag = bag.getFiltered();
        cIntBag = bag;
        cStore = stor;

        int UID = cCommand.getTaskUID();

        // Lower bound
        if (UID <= 0) {
            throw new IntegrityCommandException(USR_MSG_UPDATE_OOB);
        }
        
        // Upper bound
        if (UID > cCurBag.size()) {
            throw new IntegrityCommandException(USR_MSG_UPDATE_OOB);
        }

        // UID - 1 to get actual array mapping
        UID -= 1;

        cWhichTask = cCurBag.getTask(UID);

        verifyUpdateData();
        
        cOldTask = cWhichTask.clone();
    }

    private void verifyUpdateData() throws LogicException {
        boolean isValid;
        switch (cCommand.getTaskField()) {
            case DATE_END:
                // Check date if end date is valid to determine if task should
                // be updated.
                assert cCommand.getEnd() != null;

                isValid = Utilities.verifyDate(cWhichTask.getStart(), cCommand.getEnd());
                if (isValid == false) {
                    throw new InvalidDateException(USR_MSG_UPDATE_ENDDATE_INVALID);
                }

                break;
            case DATE_START:
                // Check date if start date is valid to determine if task should
                // be updated.
                assert cCommand.getStart() != null;

                isValid = Utilities.verifyDate(cCommand.getStart(), cWhichTask.getEnd());
                if (isValid == false) {
                    throw new InvalidDateException(USR_MSG_UPDATE_STARTDATE_INVALID);
                }

                break;
            case IMPORTANCE:
                break;
            case NAME:
                assert cCommand.getText() != null;
                break;
            default:
                break;

        }
    }

    @Override
    public Feedback execute() throws LogicException {
        Task toBeUpdated = cWhichTask;
        Feedback fb;
        String formattedString;

        switch (cCommand.getTaskField()) {
            case DATE_END:

                toBeUpdated.setEnd(cCommand.getEnd());
                cStore.save(toBeUpdated);

                formattedString = Utilities.formatString(USR_MSG_UPDATE_ENDDATE_OK, toBeUpdated.getName());
                fb = new Feedback(cCommand, cIntBag, formattedString);

                return fb;
            case DATE_START:

                toBeUpdated.setStart(cCommand.getStart());
                cStore.save(toBeUpdated);

                formattedString = Utilities.formatString(USR_MSG_UPDATE_STARTDATE_OK, toBeUpdated.getName());
                fb = new Feedback(cCommand, cIntBag, formattedString);
                return fb;

            case NAME:

                toBeUpdated.setName(cCommand.getText());
                cStore.save(toBeUpdated);

                formattedString = Utilities.formatString(USR_MSG_UPDATE_NAME_OK, toBeUpdated.getName());
                fb = new Feedback(cCommand, cIntBag, formattedString);

                return fb;
            case IMPORTANCE:

                // TODO Parser not done with this
                System.out.println("Not done yet");
                // assert cCommand.get
                // toBeUpdated.setPriority();
                break;
            default:
                assert false : cCommand.getTaskField();
        }
        return null;

    }

    @Override
    public Feedback undo() {
        Task toBeUpdated = cWhichTask;
        Feedback fb;
        String formattedString;

        switch (cCommand.getTaskField()) {
            case DATE_END:

                toBeUpdated.setEnd(cOldTask.getEnd());
                cStore.save(toBeUpdated);

                formattedString = Utilities.formatString(USR_MSG_UPDATE_UNDO, toBeUpdated.getName());
                fb = new Feedback(cCommand, cIntBag, formattedString);

                return fb;
            case DATE_START:

                toBeUpdated.setStart(cOldTask.getStart());
                cStore.save(toBeUpdated);

                formattedString = Utilities.formatString(USR_MSG_UPDATE_UNDO, toBeUpdated.getName());
                fb = new Feedback(cCommand, cIntBag, formattedString);
                return fb;

            case NAME:

                toBeUpdated.setName(cOldTask.getName());
                cStore.save(toBeUpdated);

                formattedString = Utilities.formatString(USR_MSG_UPDATE_UNDO, toBeUpdated.getName());
                fb = new Feedback(cCommand, cIntBag, formattedString);

                return fb;
            case IMPORTANCE:

                // TODO Parser not done with this
                System.out.println("Not done yet");
                // assert cCommand.get
                // toBeUpdated.setPriority();
                break;
            default:
                assert false : cCommand.getTaskField();
        }
        return null;
    }

    @Override
    public Feedback redo() throws LogicException {
        // TODO Auto-generated method stub
        return execute();
    }

}
```
