# A0125546E
###### src\common\Task.java
``` java
    public boolean hasKeyword(String keyword) {
        if (keyword == null) {
            return true;
        }

        ArrayList<String> tokens = new ArrayList<>();
        Collections.addAll(tokens, keyword.split(" "));
        return nameHasTokens(tokens);
    }

    private boolean nameHasTokens(List<String> tokens) {
        String nameLowerCase = cName.get().toLowerCase();

        for (String toCompare : tokens) {
            toCompare = toCompare.toLowerCase();
            if (nameLowerCase.contains(toCompare)) {
                return true;
            }
        }
        return false;
    }

    private void updateType() {

        if (cStart.get() == null && cEnd.get() == null) {
            cType.set(Type.FLOATING);
        } else if (cStart.get() == null && cEnd.get() != null) {
            cType.set(Type.DEADLINE);
        } else if (cStart.get() != null && cEnd.get() == null) {
            cType.set(Type.STARTONLY);
        } else if (cStart.get() != null && cEnd.get() != null) {
            cType.set(Type.EVENT);
        } else {
            assert false;
        }
    }

    public boolean isWithinDate(Date cFilterDateStart, Date cFilterDateEnd) {
        System.out.println(cFilterDateStart + " " + cFilterDateEnd);
        if (cStart.get() == null && cEnd.get() == null) {
            return false;
        } else if (cStart.get() == null) {
            // No start date, thus check end date is within period
            return isWithinBothDates(cFilterDateStart, cFilterDateEnd, cEnd.get());
        } else if (cEnd.get() == null) {
            // No end date, thus check start date is within period
            return isWithinBothDates(cFilterDateStart, cFilterDateEnd, cStart.get());
        } else {
            // Have both dates
            boolean startIsWithin = isWithinBothDates(cFilterDateStart, cFilterDateEnd, cStart.get());
            boolean endIsWithin = isWithinBothDates(cFilterDateStart, cFilterDateEnd, cEnd.get());

            return startIsWithin && endIsWithin;
        }
    }

    private boolean isWithinBothDates(Date start, Date end, Date toCompare) {
        return toCompare.before(end) && toCompare.after(start);
    }

    public boolean hasDate() {
        return cType.get() != Type.FLOATING;
    }

    /**
     * Obtains the available date that this task contains. Always gets the end
     * date before start
     */
    public Date getEndThenStartDate() {
        Date rtn = cEnd.get();
        if (rtn == null) {
            rtn = cStart.get();
        }
        return rtn;
    }

    /**
     * Obtains the available date that this task contains. Always gets the start
     * date before end
     */
    public Date getStartThenEndDate() {
        Date rtn = cStart.get();
        if (rtn == null) {
            rtn = cEnd.get();
        }
        return rtn;
    }

    /**
     * Checks if any date of the task is within x days
     */
    public boolean isWithinDays(int noOfDays) {
        Date date = getEndThenStartDate();
        if (date == null) {
            return false;
        }

        Date cur = new Date();

        long days = convertDaysToLong(noOfDays);
        long daysDifference = date.getTime() - cur.getTime();

        // Start only. Comparing if they have passed noOfDays
        if (this.getType() == Type.STARTONLY && daysDifference < days) {
            return true;
        }
        
        // Is not start but within noOfDays range
        if (this.getType() != Type.STARTONLY && daysDifference > 0 && daysDifference < days) {
            return true;
        }

        return false;
    }

    /**
     * Checks if the task is overdue
     * 
     * @return true when endDate is before current time else false
     */
    public boolean isOverDue() {
        if (getEnd() == null) {
            return false;
        } else if (getEnd().before(new Date())) {
            return true;
        } else {
            return false;
        }
    }

    private long convertDaysToLong(int days) {
        if (days <= 0) {
            return 0;
        }
        int hours = 24;
        int minutes = 60;
        int seconds = 60;
        int milliseconds = 1000;
        return days * hours * minutes * seconds * milliseconds;
    }

    /**
     * Compares if both tasks have overlapping dates.
     * 
     * @param toCompare
     *            task to be compared
     * @return true if both tasks have overlapping dates. false if either is not
     *         event type task
     */
    public boolean clashesWith(Task toCompare) {
        if (toCompare.getType() != Type.EVENT) {
            return false;
        }
        if (this.getType() != Type.EVENT) {
            return false;
        }
        boolean compareIsInThis = isWithinBothDates(toCompare.getStart(), toCompare.getEnd(), this.getStart())
                || isWithinBothDates(toCompare.getStart(), toCompare.getEnd(), this.getEnd());

        boolean thisIsInCompare = isWithinBothDates(this.getStart(), this.getEnd(), toCompare.getStart())
                || isWithinBothDates(this.getStart(), this.getEnd(), toCompare.getEnd());

        return compareIsInThis || thisIsInCompare;
    }
}
```
###### src\common\TasksBag.java
``` java
package common;

import java.util.Collections;
import java.util.Date;
import java.util.Iterator;
import java.util.logging.Logger;

import common.Task.Type;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

/**
 * Storage for Tasks Provides adding, deleting and sorting
 */
public class TasksBag implements Iterable<Task> {

    public static enum ViewType {
        COMPLETED, INCOMPLETE, DEFAULT
    }

    public static enum FilterDateState {
        NONE, AFTER, BEFORE, BETWEEN
    }

    private static final int FLOAT_LIMIT = 3;
    private static final int TASKS_LIMIT = 15;
    private static final int DEFAULT_DAY_RANGE = 3;

    private ViewType cViewType = null;
    private String cSearchState = null;
    private ObservableList<Task> tasks;

    private Date cFilterDateStart;
    private Date cFilterDateEnd;
    private FilterDateState cDateState = null;
    private Logger log;

    public TasksBag() {
        tasks = FXCollections.observableArrayList();
        log = Logger.getLogger("TasksBag");
        cViewType = ViewType.DEFAULT;
        cDateState = FilterDateState.NONE;
    }

    public FilterDateState getDateState() {
        return cDateState;
    }

    public TasksBag(ObservableList<Task> t) {
        tasks = t;
    }

    public Task getTask(int index) {
        assert index < tasks.size() : index;
        return tasks.get(index);
    }

    public Task addTask(Task c) {
        assert c != null : c;

        tasks.add(c);
        return c;
    }

    public void addTask(int index, Task c) {
        assert c != null : c;
        assert index >= 0 : index;

        tasks.add(index, c);
    }

    public int size() {
        return tasks.size();
    }

    public ObservableList<Task> getList() {
        return tasks;
    }

    public void setView(ViewType attribute) {
        assert attribute != null;
        cViewType = attribute;
    }

    public void setSearchState(String keyword) {
        cSearchState = keyword;
    }

    /**
     * Sort will return a new container as specified by current view state
     * Then sort by chronological date order
     */
    public TasksBag getFilteredView() {

        ObservableList<Task> newContainer = null;

        switch (cViewType) {
            case COMPLETED:
                newContainer = getTasksComplete();
                break;
            case INCOMPLETE:
                newContainer = getTasksIncomplete();
                break;
            case DEFAULT:
                newContainer = getTasksToday();
                break;
            default:
                assert false;
                break;
        }

        sortDateChronological(newContainer);
        // Transfer the current state to the new bag
        // UI uses the sort state to identify current tab
        TasksBag rtnBag = copyBagState(newContainer);
        return rtnBag;
    }

    /**
     * Transfers the current state of the bag into the new bag
     * 
     * @param whichBag
     *            to copy state onto
     * @return whichBag that has the same state as this bag
     */
    private TasksBag copyBagState(ObservableList<Task> whichBag) {
        TasksBag rtnBag = new TasksBag(whichBag);
        rtnBag.setView(cViewType);
        rtnBag.setSearchState(cSearchState);
        rtnBag.setFilterDateState(cFilterDateStart, cFilterDateEnd);
        return rtnBag;
    }

    private void sortDateChronological(ObservableList<Task> container) {
        Collections.sort(container, (Task t1, Task t2) -> compareDate(t1, t2));
    }

    private ObservableList<Task> getTasksComplete() {
        ObservableList<Task> rtnList = FXCollections.observableArrayList();
        /* @formatter:off */
        for (int i = 0; i < tasks.size(); i++) {
            Task curTask = tasks.get(i);
            if (curTask.isCompleted() && curTask.hasKeyword(cSearchState) 
                    && checkDateIfWithinFilter(curTask)) {
                rtnList.add(curTask);
            }
        }
        /* @formatter:on */
        return rtnList;
    }

    private ObservableList<Task> getTasksIncomplete() {
        ObservableList<Task> rtnList = FXCollections.observableArrayList();
        for (int i = 0; i < tasks.size(); i++) {
            Task curTask = tasks.get(i);
            if (curTask.isCompleted() == false && curTask.hasKeyword(cSearchState)
                    && checkDateIfWithinFilter(curTask)) {
                rtnList.add(curTask);
            }
        }
        return rtnList;
    }

    private ObservableList<Task> getTasksToday() {
        ObservableList<Task> rtnList = FXCollections.observableArrayList();
        // count # of floating
        ObservableList<Task> taskFloat = getIncompleteFloatingTasks();
        // ObservableList<Task> taskFloat2 =

        ObservableList<Task> taskNonFloat = getIncompleteDatedTasksWithDayLimit(DEFAULT_DAY_RANGE);

        int totalCount = taskFloat.size() + taskNonFloat.size();
        System.out.println(taskFloat.size());
        if (totalCount <= TASKS_LIMIT) {
            // take all
            rtnList.addAll(taskNonFloat);
            rtnList.addAll(taskFloat);
        } else {

            if (taskFloat.size() <= FLOAT_LIMIT) {
                // float count is smaller
                // fill with float then the rest with nonfloat
                rtnList.addAll(taskFloat);
                trimList(taskNonFloat, TASKS_LIMIT - rtnList.size());
                rtnList.addAll(taskNonFloat);
            } else {
                // non float count is smaller
                // fill with non float then the rest with floats
                trimList(taskNonFloat, TASKS_LIMIT - FLOAT_LIMIT);
                rtnList.addAll(taskNonFloat);

                randomizeList(taskFloat);
                trimList(taskFloat, TASKS_LIMIT - rtnList.size());
                rtnList.addAll(taskFloat);
            }
        }
        log.info("Float: " + taskFloat.size() + " Dated: " + taskNonFloat.size());
        return rtnList;
    }

    private void randomizeList(ObservableList<Task> list) {
        Collections.shuffle(list);
    }

    /**
     * Reduce the size of the list from the end of the list
     * 
     * @param taskNonFloat
     * @param i
     */
    private void trimList(ObservableList<Task> taskList, int size) {
        taskList.remove(size, taskList.size());
    }

    /**
     * Counts the number of tasks which are incomplete and has at least noOfDays
     * date
     * 
     * @return
     */
    private ObservableList<Task> getIncompleteDatedTasksWithDayLimit(int noOfDays) {
        /* @formatter:off */
        ObservableList<Task> taskList = new TaskBagBuilder(this)
                .hasDate()
                .isNotComplete()
                .hasSearchKeyword(getSearchState())
                .isWithinDayLimit(DEFAULT_DAY_RANGE)
                .build();
        /* @formatter:on */
        return taskList;
    }

    private ObservableList<Task> getInCompleteDateTasksAll() {
        /* @formatter:off */
        ObservableList<Task> taskList = new TaskBagBuilder(this)
                .isNotComplete()
                .hasDate()
                .build();
        /* @formatter:on */
        return taskList;
    }

    /**
     * Counts the number of tasks which are incomplete and has at least 1 date
     * 
     * @return
     */
    private ObservableList<Task> getIncompleteFloatingTasks() {
        /* @formatter:off */
        ObservableList<Task> taskList = new TaskBagBuilder(this)
                .noDate()
                .isNotComplete()
                .hasSearchKeyword(getSearchState())
                .build();

        /* @formatter:on */
        return taskList;
    }

    private boolean checkDateIfWithinFilter(Task curTask) {
        if (cFilterDateEnd == null || cFilterDateStart == null) {
            return true;
        } else {
            return curTask.isWithinDate(cFilterDateStart, cFilterDateEnd);
        }
    }

    public Task removeTask(int index) {
        assert index >= 0 : index;
        assert index <= tasks.size() - 1 : index;

        Task rtnCelebi = tasks.remove(index);
        return rtnCelebi;
    }

    public int removeTask(Task t) {
        assert t != null : "Null task";

        int rtnIndex = tasks.indexOf(t);
        assert rtnIndex >= 0 : rtnIndex;

        tasks.remove(rtnIndex);

        return rtnIndex;
    }

    private int compareDate(Task t1, Task t2) {
        assert t1 != null;
        assert t2 != null;

        Date firstCom, secCom;

        firstCom = getAnyDate(t1);
        secCom = getAnyDate(t2);

        if (firstCom == null && secCom == null) {
            return 0;
        } else if (secCom == null) {
            return -1;
        } else if (firstCom == null) {
            return 1;
        } else {
            return firstCom.compareTo(secCom);
        }
    }

    private Date getAnyDate(Task t1) {
        Date date = null;
        if (t1.getStart() != null) {
            date = t1.getStart();
        } else if (t1.getEnd() != null) {
            date = t1.getEnd();
        }
        return date;
    }

    @Override
    public Iterator<Task> iterator() {
        return tasks.iterator();
    }

    public ViewType getView() {
        return cViewType;
    }

    public boolean isEmpty() {
        return tasks.size() == 0;
    }

    public void setFilterDateState(Date start, Date end) {
        cFilterDateStart = start;
        cFilterDateEnd = end;
        updateFilterDateState();
    }

    public void updateFilterDateState() {
        if (cFilterDateStart == null && cFilterDateEnd == null) {
            cDateState = FilterDateState.NONE;
        } else if (cFilterDateStart.equals(Utilities.absBeginningTime())) {
            cDateState = FilterDateState.BEFORE;
        } else if (cFilterDateEnd.equals(Utilities.absEndingTime())) {
            cDateState = FilterDateState.AFTER;
        } else {
            cDateState = FilterDateState.BETWEEN;
        }
    }

    public Date getStartDate() {
        return cFilterDateStart;
    }

    public Date getEndDate() {
        return cFilterDateEnd;
    }

    public String getSearchState() {
        return cSearchState;
    }

    public void toggleView() {
        switch (cViewType) {
            case COMPLETED:
                cViewType = ViewType.INCOMPLETE;
                break;
            case INCOMPLETE:
                cViewType = ViewType.DEFAULT;
                break;
            case DEFAULT:
                cViewType = ViewType.COMPLETED;
                break;
            default:
                log.severe("Default view state encountered during toggleFilter.");
                cViewType = ViewType.DEFAULT;
                break;
        }
    }

    public ObservableList<Task> findClashesWithIncomplete(Task t) {
        ObservableList<Task> clashList = FXCollections.observableArrayList();
        ObservableList<Task> lists = getInCompleteDateTasksAll();

        if (t.getType() != Type.EVENT) {
            return clashList;
        }

        lists.forEach(curTask -> {
            if (t.clashesWith(curTask)) {
                clashList.add(curTask);
            }
        });
        return clashList;
    }
}
```
###### src\common\Utilities.java
``` java
    /**
     * Evaluates if start and end dates are valid where end is after start
     * 
     * @param dateStart
     * @param dateEnd
     * @return true if either start or end is null. false if start is after end
     */
    public static final boolean verifyDate(Date dateStart, Date dateEnd) {
        if (dateStart != null && dateEnd != null && dateStart.after(dateEnd)) {
            return false;
        }
        return true;
    }

    public static final String formatString(String s, Object... args) {
        String formatted = String.format(s, args);
        return formatted;

    }

    /**
     * Provides the beginning of time in Unix term
     * 
     * @return the epoch
     */
    public static Date absBeginningTime() {
        return new Date(Long.MIN_VALUE);
    }

    /**
     * Provides the ending of time in Unix term 64-bit
     * 
     * @return end date
     */
    public static Date absEndingTime() {
        return new Date(Long.MAX_VALUE);
    }

    /**
     * Prepend and append empty spaces to the text
     * @param text to be modified
     * @param number of spacings to be added
     */
    public static String textSpacer(String text, int spacing) {
        String space = " ";
        StringBuilder spaces = new StringBuilder(); 
        StringBuilder returnText = new StringBuilder();
        for(int i = 0; i < spacing; i++){
            spaces.append(space);
        }
        
        returnText.append(spaces.toString());
        returnText.append(text);
        returnText.append(spaces.toString());
        return returnText.toString();
    }
    
```
###### src\logic\Action.java
``` java
package logic;

import logic.exceptions.LogicException;

public interface Action {
	public Feedback execute() throws LogicException;
}
```
###### src\logic\ActionInvoker.java
``` java
package logic;

import java.util.ArrayList;

import logic.exceptions.LogicException;
import logic.exceptions.NoRedoActionException;
import logic.exceptions.NoUndoActionException;

/***
 * Invoker part of Command Pattern Deals with keeping track of what actions have
 * been done, Undo/Redo support.
 * 
 * Note the issue when redo-ing on a "switched" filter on the bag. Might cause
 * unintended side effects
 */

public class ActionInvoker {

    private final String MSG_NO_UNDO = "No undoable actions found.";
    private final String MSG_NO_REDO = "No redoable actions found.";
    private ArrayList<Action> cUndo;
    private ArrayList<Action> cRedo;

    public ActionInvoker() {
        cUndo = new ArrayList<Action>();
        cRedo = new ArrayList<Action>();
    }

    public Feedback placeAction(Action act) throws LogicException {
        assert cUndo != null : "Undo arraylist is null";

        // execute may throw exceptions
        Feedback fb = act.execute();

        // If execution passes, then we add into undo queue
        if (act instanceof UndoableAction) {
            cUndo.add(act);

            // Clearing redo list, should not have redo possible
            // if new actions executed
            cRedo.clear();
        }
        return fb;
    }

    public Feedback undoAction() throws NoUndoActionException {
        assert cUndo != null : "Undo arraylist is null";

        if (cUndo.size() == 0) {
            throw new NoUndoActionException(MSG_NO_UNDO);
        }

        UndoableAction undoAction = (UndoableAction) cUndo.remove(cUndo.size() - 1);
        cRedo.add(undoAction);

        return undoAction.undo();
    }

    public Feedback redoAction() throws NoRedoActionException, LogicException {
        assert cRedo != null : "Redo arraylist is null";

        if (cRedo.size() == 0) {
            throw new NoRedoActionException(MSG_NO_REDO);
        }

        UndoableAction redoAction = (UndoableAction) cRedo.remove(cRedo.size() - 1);
        cUndo.add(redoAction);

        return redoAction.redo();
    }
}
```
###### src\logic\AddAction.java
``` java
package logic;

import java.util.Date;
import common.Task;
import common.TasksBag;
import common.Utilities;
import javafx.collections.ObservableList;
import logic.exceptions.IntegrityCommandException;
import logic.exceptions.LogicException;
import parser.commands.CommandData;
import storage.StorageInterface;

/**
 * Adds tasks into internal bag Undo removes the task
 */
public class AddAction implements UndoableAction {

    private static final String USR_MSG_ADD_OK = "Added %1$s!";
    private static final String USR_MSG_ADD_UNDO = "Undo adding %1$s!";
    private static final String USR_MSG_ADD_ERROR_DATE = "Failed to add! Start date is after end date!";
    private static final String USR_MSG_ADD_ERROR_LONG_NAME = "Failed to add! Your task name is too long! Keep it "
            + "to less than 50 characters.";
    private static final String USR_MSG_ADD_WARNING_CLASH_SINGLE = "Your task clashes with %1$s!";
    private static final String USR_MSG_ADD_WARNING_CLASH_MANY = "Your task clashes with %1$s and %2$s more!";
    private static final String USR_MSG_ADD_WARNING_OVERDUE = "Your task is already over due!";
    private static final String USR_MSG_ADD_WARNING_STORE_FAIL = "Fail to update the storage file!";
    private static final int NAME_LIMIT = 50; // Hard limit for user's max char

    private CommandData cCommand;
    private TasksBag cBag;
    private StorageInterface cStore;
    private Task cWhichTask;
    private boolean cAddSuccess;
    private boolean cDeleteSuccess;

    public AddAction(CommandData command, TasksBag bag, StorageInterface stor) throws IntegrityCommandException {
        cCommand = command;
        cBag = bag;
        cStore = stor;

        String name = cCommand.getText();
        Date startDate = cCommand.getStart();
        Date endDate = cCommand.getEnd();

        validateTaskName(name);
        validateDate(startDate, endDate);
        
        cWhichTask = new Task(name, startDate, endDate);
    }

    @Override
    public CommandFeedback execute() throws LogicException {
        String formattedString;
        String warningString;
        CommandFeedback fb;
        
        cBag.addTask(cWhichTask);
        cAddSuccess = cStore.save(cWhichTask);

        warningString = processWarningMsg();

        formattedString = Utilities.formatString(USR_MSG_ADD_OK, cWhichTask.getName());
        fb = new CommandFeedback(cCommand, cBag, formattedString, warningString);

        return fb;
    }

    private String processWarningMsg() {
    	String warningStrings = "";
    	
    	if (!cAddSuccess) {
    		warningStrings = Utilities.appendWarningStrings(warningStrings, USR_MSG_ADD_WARNING_STORE_FAIL);
    	}
    	
        // Over due has a higher priority than clashes
        if (cWhichTask.isOverDue()) {
        	warningStrings = Utilities.appendWarningStrings(warningStrings, USR_MSG_ADD_WARNING_OVERDUE);
        	return warningStrings;
        }

        ObservableList<Task> clashList = cBag.findClashesWithIncomplete(cWhichTask);

        if (clashList == null || clashList.size() == 0) {
            return warningStrings;
        }

        Task firstTask = clashList.get(0);
        String formatted;
        if (clashList.size() > 1) {
            int noOfOtherClashes = clashList.size() - 1;
            formatted = Utilities.formatString(USR_MSG_ADD_WARNING_CLASH_MANY, firstTask.getName(), noOfOtherClashes);
            warningStrings = Utilities.appendWarningStrings(warningStrings, formatted);
        } else {
        	formatted = Utilities.formatString(USR_MSG_ADD_WARNING_CLASH_SINGLE, firstTask.getName());
        	warningStrings = Utilities.appendWarningStrings(warningStrings, formatted);
        }
        return warningStrings;
    }

    @Override
    public CommandFeedback undo() {
        assert cWhichTask != null;
        String formatted;
        String warning = "";

        cDeleteSuccess = cStore.delete(cWhichTask);
        cBag.removeTask(cWhichTask);
        
        formatted = Utilities.formatString(USR_MSG_ADD_UNDO, cWhichTask.getName());
        
        if (!cDeleteSuccess) {
        	warning = USR_MSG_ADD_WARNING_STORE_FAIL;
        }
        
        return new CommandFeedback(cCommand, cBag, formatted, warning);
    }

    @Override
    public CommandFeedback redo() throws LogicException {
        return execute();
    }

    private void validateDate(Date startDate, Date endDate) throws IntegrityCommandException {
        boolean isValidDate = Utilities.verifyDate(startDate, endDate);
        
        if (isValidDate == false) {
            throw new IntegrityCommandException(USR_MSG_ADD_ERROR_DATE);
        }
    }

    private void validateTaskName(String name) throws IntegrityCommandException {
        if (name.length() > NAME_LIMIT) {
            throw new IntegrityCommandException(USR_MSG_ADD_ERROR_LONG_NAME);
        }
    }
}
```
###### src\logic\CommandFeedback.java
``` java
package logic;

import common.TasksBag;
import parser.commands.CommandData;

/*
 * Wrapper class to contain Command type and 
 * CelebiBag for UI
 */
public class CommandFeedback extends Feedback {

    private final CommandData cCommand;
    private String cMsg;
    private String cWarning;

    public CommandFeedback(CommandData comd, TasksBag bag) {
        super(bag);
        cCommand = comd;
    }

    public CommandFeedback(CommandData comd, TasksBag bag, String msg) {
        this(comd, bag);
        cMsg = msg;
    }

    public CommandFeedback(CommandData comd, TasksBag bag, String msg, String warning) {
        this(comd, bag);
        cMsg = msg;
        cWarning = warning;
    }

    public CommandData getCommand() {
        return cCommand;
    }

    public String getMsg() {
        return cMsg;
    }

    public String getWarningMsg() {
        return cWarning;
    }

    public void setMsg(String msg) {
        cMsg = msg;
    }

}
```
###### src\logic\DeleteAction.java
``` java
package logic;

import java.util.logging.Logger;

import common.Task;
import common.TasksBag;
import common.Utilities;
import logic.exceptions.IllegalAccessCommandException;
import logic.exceptions.IntegrityCommandException;
import logic.exceptions.LogicException;
import parser.commands.CommandData;
import storage.StorageInterface;

/***
 * Note that due to execute being called again when redo-ing. The task to be
 * deleted has to be decided at INIT/Constructor time. Not at execution time.
 */
public class DeleteAction implements UndoableAction {

    private static final String USR_MSG_DELETE_OOB = "Provided index not on list.";
    private static final String USR_MSG_DELETE_OK = "Removed %1$s!";
    private static final String USR_MSG_DELETE_UNDO = "Undoing delete %1$s";
    
    private static final String USR_MSG_DELETE_WARNING_STORE_FAIL = "Fail to update the storage file!";

    private CommandData cCommand;
    private TasksBag cCurBag;
    private TasksBag cIntBag;
    private StorageInterface cStore;
    private Task cWhichTask; // The task to be modified
    private int cPosition; // Position of internal bag
    private boolean cDeleteSuccess;
    private boolean cAddSuccess;
    Logger log;

    /**
     * Returns a Delete Action object in the internal bag. References the curBag
     * to get the actual internalbag task
     *
     * @param command
     *            Command of the action
     * @param curBag
     *            Current bag status internalBag Internal bag
     * @param stor
     *            Storage pointer
     * @throws IntegrityCommandException
     *             When provided with an index that will access OOB values
     * @throws IllegalAccessCommandException 
     */
    public DeleteAction(CommandData command, TasksBag internalBag, StorageInterface stor) throws IllegalAccessCommandException {
        assert internalBag != null;
        assert stor != null;
        assert command != null;

        cCommand = command;
        cCurBag = internalBag.getFilteredView();
        cIntBag = internalBag;
        cStore = stor;
        log = Logger.getLogger("DeleteAction");

        // Find the offending command and lock it at init time
        int UID = cCommand.getTaskUID();

        if (UID <= 0) {
            throw new IllegalAccessCommandException(USR_MSG_DELETE_OOB);
        }
        if (UID > cCurBag.size()) {
            throw new IllegalAccessCommandException(USR_MSG_DELETE_OOB);
        }

        // UID - 1 to get array index
        UID -= 1;

        cWhichTask = cCurBag.getTask(UID);
    }

    /**
     * Attempts to execute the action Returns Feedback of the action
     * 
     * @throws IntegrityCommandException
     *             If deleting out of bound
     */
    @Override
    public CommandFeedback execute() throws LogicException {
        String formattedString;
        String warningString = "";

        cPosition = cIntBag.removeTask(cWhichTask);
        cDeleteSuccess = cStore.delete(cWhichTask);

        formattedString = Utilities.formatString(USR_MSG_DELETE_OK, cWhichTask.getName());
        
        if (!cDeleteSuccess) {
        	warningString = USR_MSG_DELETE_WARNING_STORE_FAIL;
        }
        
        return new CommandFeedback(cCommand, cIntBag, formattedString, warningString);
    }

    /**
     * Insert task back into internal bag at removed position Saves task back
     * into storage
     */
    @Override
    public CommandFeedback undo() {
        String formattedString;
        String warningString = "";
        
        formattedString = Utilities.formatString(USR_MSG_DELETE_UNDO, cWhichTask.getName());

        cIntBag.addTask(cPosition, cWhichTask);
        cAddSuccess = cStore.save(cWhichTask);
        
        if (!cAddSuccess) {
        	warningString = USR_MSG_DELETE_WARNING_STORE_FAIL;
        }

        return new CommandFeedback(cCommand, cIntBag, formattedString, warningString);
    }

    /**
     * Remove task object from bag Deletes task at storage
     */
    @Override
    public CommandFeedback redo() throws LogicException {
        return execute();
    }
}
```
###### src\logic\exceptions\ActionException.java
``` java
package logic.exceptions;

public class ActionException extends LogicException {
    
    private static final long serialVersionUID = 663428951026655012L;

    public ActionException(String msg) {
        super(msg);
    }

}
```
###### src\logic\exceptions\AlreadyMarkedException.java
``` java
package logic.exceptions;

public class AlreadyMarkedException extends LogicException {

    private static final long serialVersionUID = 7605084398231648593L;

    public AlreadyMarkedException(String msg) {
        super(msg);
    }

}
```
###### src\logic\exceptions\AlreadyUnmarkedException.java
``` java
package logic.exceptions;

public class AlreadyUnmarkedException extends LogicException {

    private static final long serialVersionUID = 4423335997573387768L;

    public AlreadyUnmarkedException(String msg) {
        super(msg);
    }

}
```
###### src\logic\exceptions\IllegalAccessCommandException.java
``` java
package logic.exceptions;

public class IllegalAccessCommandException extends LogicException {
    private static final long serialVersionUID = -1205053410414852622L;

    public IllegalAccessCommandException(String msg) {
        super(msg);
    }

}
```
###### src\logic\exceptions\IntegrityCommandException.java
``` java
package logic.exceptions;

public class IntegrityCommandException extends LogicException {

    private static final long serialVersionUID = -7658067372077628329L;

    public IntegrityCommandException(String msg) {
        super(msg);
    }
}
```
###### src\logic\exceptions\InvalidDateException.java
``` java
package logic.exceptions;

public class InvalidDateException extends IntegrityCommandException {

    private static final long serialVersionUID = -7002613567304746646L;

    public InvalidDateException(String msg) {
        super(msg);
        // TODO Auto-generated constructor stub
    }

}
```
###### src\logic\exceptions\LogicException.java
``` java
package logic.exceptions;

public class LogicException extends Exception {

	private static final long serialVersionUID = 8103789619642292889L;
	public final String cMsg;

	public LogicException(String msg){
		cMsg = msg;
	}
}
```
###### src\logic\exceptions\NoRedoActionException.java
``` java
package logic.exceptions;

public class NoRedoActionException extends ActionException {

    private static final long serialVersionUID = -5029418244543740195L;

    public NoRedoActionException(String msg) {
        super(msg);
    }

}
```
###### src\logic\exceptions\NoUndoActionException.java
``` java
package logic.exceptions;

public class NoUndoActionException extends ActionException {

    private static final long serialVersionUID = -6305570505075435759L;

    public NoUndoActionException(String msg) {
        super(msg);
    }
}
```
###### src\logic\exceptions\UnknownCommandException.java
``` java
package logic.exceptions;

public class UnknownCommandException extends LogicException {

    private static final long serialVersionUID = -7836866875248053818L;

    public UnknownCommandException(String msg) {
        super(msg);
    }

}
```
###### src\logic\Feedback.java
``` java
public class Feedback {
    private final TasksBag cBag;

    public Feedback(TasksBag bag) {
        cBag = bag;
    }

    /**
     * Provides the current sorted state of bag for UI
     * 
     * @return sorted state of bag
     */
    public TasksBag getcBag() {
        return cBag.getFilteredView();
    }
}
```
###### src\logic\FilterClearAction.java
``` java
package logic;

import common.TasksBag;
import parser.commands.CommandData;

public class FilterClearAction implements Action {
    
    private static final String USR_MSG_FILTER_CLEAR = "Cleared searches and filters!";

    private CommandData cCommand;
    private TasksBag cBag;

    public FilterClearAction(CommandData rtnCmd, TasksBag cInternalBag) {
        cCommand = rtnCmd;
        cBag = cInternalBag;
    }

    @Override
    public Feedback execute() {
        String msg = USR_MSG_FILTER_CLEAR;
        
        cBag.setSearchState(null);
        cBag.setFilterDateState(null, null);
        CommandFeedback fb = new CommandFeedback(cCommand, cBag, msg);
        return fb;
    }

}
```
###### src\logic\FilterDateAction.java
``` java
package logic;

import java.util.Date;

import common.TasksBag;
import common.Utilities;
import logic.exceptions.InvalidDateException;
import parser.commands.CommandData;
import ui.view.DateFormatter;

public class FilterDateAction implements Action {

    private static final String USR_MSG_FILTER_AFTER_DATE = "Filtering dates after %1$s";
    private static final String USR_MSG_FILTER_BEFORE_DATE = "Filtering dates before %1$s";
    private static final String USR_MSG_FILTER_BETWEEN_DATE = "Filtering dates between %1$s and %2$s";
    private static final String USR_MSG_FILTER_INVALID_SEARCH_DATE = "I can't search for a start date that is after end date!";
    private CommandData cCommand;
    private TasksBag cBag;
    private Date cStart;
    private Date cEnd;

    public FilterDateAction(CommandData command, TasksBag internalBag) throws InvalidDateException {
        cCommand = command;
        cBag = internalBag;
        cStart = cCommand.getStart();
        cEnd = cCommand.getEnd();
        boolean isValid = Utilities.verifyDate(cStart, cEnd);
        if (isValid == false) {
            throw new InvalidDateException(USR_MSG_FILTER_INVALID_SEARCH_DATE);
        }
    }

    @Override
    public CommandFeedback execute() {
        CommandFeedback fb;

        cBag.setFilterDateState(cStart, cEnd);
        TasksBag.FilterDateState dState = cBag.getDateState();

        fb = new CommandFeedback(cCommand, cBag, getFeedbackText(dState));
        return fb;
    }

    private String getFeedbackText(TasksBag.FilterDateState state) {
        String rtn = "";
        String formatStart;
        String formatEnd;
        DateFormatter df = new DateFormatter();
        switch (state) {
            case AFTER:
                formatStart = df.formatDate(cStart);
                rtn = Utilities.formatString(USR_MSG_FILTER_AFTER_DATE, formatStart);
                break;

            case BEFORE:
                formatEnd = df.formatDate(cEnd);
                rtn = Utilities.formatString(USR_MSG_FILTER_BEFORE_DATE, formatEnd);
                break;
            case BETWEEN:
                formatStart = df.formatDate(cStart);
                formatEnd = df.formatDate(cEnd);
                rtn = Utilities.formatString(USR_MSG_FILTER_BETWEEN_DATE, formatStart, formatEnd);
                break;
            default:
                break;
        }
        return rtn;
    }

}
```
###### src\logic\HelpAction.java
``` java
package logic;

import common.TasksBag;
import logic.exceptions.LogicException;
import parser.HelpStrings;
import parser.commands.CommandData;

public class HelpAction implements Action {

    private static final String USR_MSG_HELP_INVALID = "You can view the help for this command by typing it out by itself!";
    private CommandData cCommand;
    private TasksBag cBag;

    public HelpAction(CommandData rtnCmd, TasksBag bag) {
        cCommand = rtnCmd;
        cBag = bag;
    }

    @Override
    public CommandFeedback execute() throws LogicException {
        String msg = "";
        CommandFeedback fb;

        msg = generateHelpString();

        fb = new CommandFeedback(cCommand, cBag, msg);
        return fb;
    }

    private String generateHelpString() {
        String msg;
        if(cCommand.getSecondaryCmdType() == null){
            return HelpStrings.HELP_LIST_ALL_CMDS;
        }
        
        switch (cCommand.getSecondaryCmdType()) {
            case HELP:
                msg = HelpStrings.HELP_LIST_ALL_CMDS;
                break;
            default:
                msg = USR_MSG_HELP_INVALID;
                break;

        }
        return msg;
    }
}
```
###### src\logic\Logic.java
``` java
package logic;

import java.util.logging.Logger;

import common.TasksBag;
import common.TasksBag.ViewType;
import javafx.scene.input.KeyCode;
import logic.exceptions.IntegrityCommandException;
import logic.exceptions.LogicException;
import logic.exceptions.UnknownCommandException;
import parser.ParserController;
import parser.ParserControllerImpl;
import parser.commands.CommandData;
import storage.Storage;
import storage.StorageInterface;

public class Logic implements LogicInterface {

    private static final String USR_MSG_UNKNOWN_COMMAND = "I couldn't understand you... (>.<)";

    // The default view when UI first query the bag
    private static final ViewType DEFAULT_UI_VIEW = TasksBag.ViewType.DEFAULT;
    private static final KeyCode TOGGLE_FILTER_STATE_KEY = KeyCode.TAB;
    private StorageInterface cStorage;
    private ParserController cParser;
    private TasksBag cInternalBag;
    private ActionInvoker cInvoker;
    private Logger log;

    public Logic() {
        cInternalBag = new TasksBag();
        cInvoker = new ActionInvoker();
        log = Logger.getLogger("Filter");
    }

    @Override
    public void init() {

        cStorage = Storage.getStorage();
        cStorage.init();
        cParser = ParserControllerImpl.getParser();
        cParser.init();

        System.out.println("Logic Init complete");
    }

    /**
     * Passes string param to parser then evaluates the command type
     * 
     * @exception IntegrityCommandException
     *                When given input violates validity
     * @exception InvalidCommandException
     *                When given input cannot be understood
     * @param userString
     *            string value entered by user
     */
    @Override
    public CommandFeedback executeCommand(String userString) throws LogicException {
        assert userString != null;

        CommandData rtnCmd = cParser.parseCommandData(userString);
        log.info("executing " + userString);
        return executeParsed(rtnCmd);
    }

    private CommandFeedback executeParsed(CommandData rtnCmd) throws LogicException {

        Feedback fb;
        switch (rtnCmd.getCmdType()) {
            case ADD:
                fb = cInvoker.placeAction(new AddAction(rtnCmd, cInternalBag, cStorage));
                break;
            case DELETE:
                fb = cInvoker.placeAction(new DeleteAction(rtnCmd, cInternalBag, cStorage));
                break;
            case SHOW:
                fb = cInvoker.placeAction(new ViewAction(rtnCmd, cInternalBag));
                break;
            case UPDATE:
                fb = cInvoker.placeAction(new UpdateAction(rtnCmd, cInternalBag, cStorage));
                break;
            case MARK:
                fb = cInvoker.placeAction(new MarkAction(rtnCmd, cInternalBag, cStorage));
                break;
            case UNMARK:
                fb = cInvoker.placeAction(new UnmarkAction(rtnCmd, cInternalBag, cStorage));
                break;
            case UNDO:
                fb = cInvoker.undoAction();
                break;
            case REDO:
                fb = cInvoker.redoAction();
                break;
            case FILTER_DATE:
                fb = cInvoker.placeAction(new FilterDateAction(rtnCmd, cInternalBag));
                break;
            case MOVE:
                fb = cInvoker.placeAction(new MoveFileAction(rtnCmd, cInternalBag, cStorage));
                break;
            case QUIT:
                fb = new CommandFeedback(rtnCmd, null);
                break;
            case SEARCH:
                fb = cInvoker.placeAction(new SearchAction(rtnCmd, cInternalBag));
                break;
            case HELP:
                fb = cInvoker.placeAction(new HelpAction(rtnCmd, cInternalBag));
                break;
            case THEME:
                fb = cInvoker.placeAction(new ThemeChangeAction(rtnCmd, cInternalBag));
                break;
            case CLEAR_FILTERS:
                fb = cInvoker.placeAction(new FilterClearAction(rtnCmd, cInternalBag));
                break;
            case ALIAS:
            	fb = cInvoker.placeAction(new AliasAction(rtnCmd, cInternalBag));
            	break;
            case INVALID:
                throw new UnknownCommandException(USR_MSG_UNKNOWN_COMMAND);
            default:
                assert false : rtnCmd.getCmdType();
                fb = new CommandFeedback(rtnCmd, cInternalBag);
                break;
        }
        return (CommandFeedback) fb;
    }

    @Override
    public boolean initData(String s) {

        boolean rtnVal = cStorage.load(cInternalBag);
        return rtnVal;
    }

    @Override
    public TasksBag getTaskBag() {
        return cInternalBag;
    }

    public void setStorage(StorageInterface storageStub) {
        System.out.println("Stub added for storage");
        cStorage = storageStub;
    }

    public void setParser(ParserController parserStub) {
        System.out.println("STUB ADDED FOR PARSER");
        cParser = parserStub;
    }

    @Override
    public TasksBag getDefaultBag() {
        cInternalBag.setView(DEFAULT_UI_VIEW);
        return cInternalBag.getFilteredView();
    }

    public void close() {
        cStorage.close();
    }

    @Override
    public KeyEventFeedback executeKeyEvent(KeyCode whichKey) throws LogicException {
        KeyEventFeedback fb = null;
        if (whichKey == TOGGLE_FILTER_STATE_KEY) {
            fb = (KeyEventFeedback) cInvoker.placeAction(new ViewToggleAction(cInternalBag, whichKey));
        }
        return fb;
    }
}
```
###### src\logic\LogicInterface.java
``` java
package logic;


import common.TasksBag;
import javafx.scene.input.KeyCode;
import logic.exceptions.LogicException;

public interface LogicInterface {

    public void init();

    public boolean initData(String s); // Returns true if successfully init data

    public CommandFeedback executeCommand(String cmd) throws LogicException;
    public KeyEventFeedback executeKeyEvent(KeyCode whichKey) throws LogicException;
    public TasksBag getTaskBag();

    public TasksBag getDefaultBag();

    public void close();
}
```
###### src\logic\LogicTest.java
``` java
package logic;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Random;
import java.util.Date;

import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import common.Task;
import common.TasksBag;
import logic.exceptions.AlreadyMarkedException;
import logic.exceptions.AlreadyUnmarkedException;
import logic.exceptions.IllegalAccessCommandException;
import logic.exceptions.LogicException;
import logic.exceptions.NoRedoActionException;
import logic.exceptions.NoUndoActionException;
import logic.exceptions.UnknownCommandException;

public class LogicTest {

    private static final String JSON_LOC_DEFAULT = "bin/task.json";
    private static final String JSON_LOC_TEMP = "bin/temp.json";
    private static final String JSON_LOC_FINAL = "bin/test/";
    static Logic logic;

    @Before
    public void initTest() {
        init();
    }

    @After
    public void cleanUpTest() {
        //cleanUp();
    }

    @Test
    public void Coverage() {

        // Logic.java
        testFailException("", UnknownCommandException.class);
        testFailException("wrong add undo remove quit exit delete", UnknownCommandException.class);
        testFailException("khasd", UnknownCommandException.class);
        testFailException("undo", NoUndoActionException.class);
        testFailException("redo", NoRedoActionException.class);
        testFailException("remove 1", IllegalAccessCommandException.class);
        testFailException("remove 0", IllegalAccessCommandException.class);

        // AddAction.java
        testPass("add task 1");
        testPass("add task 2");
        testPass("undo");
        testPass("redo");

        // DeleteAction.java
        testFailException("delete 0", IllegalAccessCommandException.class);
        testFailException("delete 3", IllegalAccessCommandException.class);
        testPass("delete 1");
        testPass("undo");
        testPass("redo");

        // UpdateAction.java
        testPass("show undone");
        testFailException("update 0 name hello", IllegalAccessCommandException.class);
        testFailException("update 3 name hello", IllegalAccessCommandException.class);
        testPass("update 1 name hello");
        testFailException("update 1 start hello", UnknownCommandException.class);
        testPass("update 1 start 2015-10-10 15:00");
        testPass("update 1 end now");
        testPass("undo");
        testPass("redo");

        // Show
        testPass("show");
        testPass("show done");
        testFailException("delete 1", IllegalAccessCommandException.class);
        testPass("show undone");

        // Mark/Unmark
        testFailException("unmark 1", AlreadyUnmarkedException.class);
        testPass("mark 1");
        testFailException("mark 0", IllegalAccessCommandException.class);
        testPass("undo");
        testPass("redo");
        testPass("show done");
        testPass("unmark 1");
        testPass("undo");
        testPass("redo");
        testPass("show done");

        // Search
        testPass("search hello");
        testPass("show");
        testPass("show done");
        testPass("show complete");
        testPass("show undone");
        testPass("show incomplete");
        testPass("show default");
        testFailException("show tod1", UnknownCommandException.class);
        // filter
        testPass("filter after now");
        testPass("filter before now");
        testPass("filter from now to tmr");

        // help
        testPass("help");
        testPass("help help");
        testFailException("help 1", UnknownCommandException.class);

    }

    @Test
    public void AddStressTest() {
        int TASK_COUNT = 50;
        TasksBag temp;
        Task tempTask;
        Random rng = new Random();

        int rndVal = rng.nextInt(TASK_COUNT);

        for (int i = 0; i < rndVal; i++) {
            testPass("add name " + i);
        }

        temp = logic.getTaskBag();
        Assert.assertEquals(rndVal, temp.size());

        for (int i = 0; i < rndVal; i++) {
            tempTask = temp.getTask(i);

            Assert.assertEquals(false, tempTask.isCompleted());
            Assert.assertEquals(null, tempTask.getStart());
            Assert.assertEquals(null, tempTask.getEnd());
            Assert.assertEquals("name " + i, tempTask.getName());
        }
    }

    @Test
    public void AddSymbols() {
        // Valid symbols. The only invalid is ;
        String symbols = ",./<>?:'\"[]{}\\|=+=~-_!@#$%^&*()`";
        testPass("add " + symbols);
        Task addedTask = logic.getTaskBag().getTask(0);
        System.out.println(addedTask.getName());
        Assert.assertTrue(symbols.equals(addedTask.getName()));
        testPass("delete 1");
    }

    @Test
    public void AddTrailingSpaces() {
        String taskName = "takoyaki";
        testPass("  \n  \t   add " + taskName + "     ");
        Task addedTask = logic.getTaskBag().getTask(0);
        Assert.assertTrue(taskName.equals(addedTask.getName()));
        testPass("delete 1");
    }

    @Test
    public void AddNeg() {

        // Nameless tasks and symbols variants
        testFailException("add", UnknownCommandException.class);
        testFailException("add ", UnknownCommandException.class);
        testFailException("add\n", UnknownCommandException.class);
        testFailException("add\t", UnknownCommandException.class);
        testFailException("add!?", UnknownCommandException.class);
        testFailException("a!dd task", UnknownCommandException.class);
        testFailException("add;", UnknownCommandException.class);
    }

    @Test
    public void Delete() {
        // Boundary for fail. Empty entry
        testFailException("d -1", IllegalAccessCommandException.class);
        testFailException("d 0", IllegalAccessCommandException.class);
        testFailException("d 1", IllegalAccessCommandException.class);

        testPass("add one");
        // Boundary for fail. 0 and 2 with size 1
        testFailException("d 0", IllegalAccessCommandException.class);
        testFailException("d 2", IllegalAccessCommandException.class);
    }

    @Test
    public void Mark() {
        Task t;
        // Boundary for 0 entry but trying to mark
        testFailException("mark 0", IllegalAccessCommandException.class);

        testPass("add one");
        testPass("mark 1");

        t = logic.getTaskBag().getTask(0);
        Assert.assertEquals(true, t.isCompleted());

        // fail test under INCOMPLETE(default) filter of tasksbag
        testFailException("mark 1", IllegalAccessCommandException.class);

        logic.getTaskBag().setView(TasksBag.ViewType.COMPLETED);

        testFailException("mark 1", AlreadyMarkedException.class);

        // Can access task bag due to COMPLETE filter now
        t = logic.getTaskBag().getTask(0);
        Assert.assertEquals(true, t.isCompleted());
    }

    @Test
    public void Unmark() {
        // Boundary for 0 entry but trying to unmark
        Task t;
        testFailException("unmark 0", IllegalAccessCommandException.class);

        testPass("add one");
        testFailException("unmark 1", AlreadyUnmarkedException.class);

        t = logic.getTaskBag().getTask(0);
        Assert.assertEquals(false, t.isCompleted());

        // Unmark twice onto same object. Should throw exception
        testFailException("unmark 1", AlreadyUnmarkedException.class);

        t = logic.getTaskBag().getTask(0);
        Assert.assertEquals(false, t.isCompleted());

        // Mark and unmarking
        testPass("mark 1");
        testPass("show done");
        testPass("unmark 1");
        Assert.assertEquals(false, t.isCompleted());
    }

    @Test
    public void TaskSearchKeyword() {
        Task k = new Task("LowerCase UpperCase", null, null);

        // Half match case mixcase
        Assert.assertEquals(true, k.hasKeyword("LowerCase"));
        // Full match case mixrcase
        Assert.assertEquals(true, k.hasKeyword("lowerCase uppErCase"));
        // substring case
        Assert.assertEquals(true, k.hasKeyword("er"));
        // non substring
        Assert.assertEquals(false, k.hasKeyword("ber"));
        // Empty string
        Assert.assertEquals(true, k.hasKeyword(""));
        // Null string
        Assert.assertEquals(true, k.hasKeyword(null));

    }

    @Test
    public void DateInvalidDates() {
        // Invalid due to out of normal date range
        testFailException("a task; from 2015_13_1, 10:00", UnknownCommandException.class);
        testFailException("a task; from 2015-2-28, 10:00 to 2015_2_29, 10:01", UnknownCommandException.class);
        testFailException("a task; from 2015-2-29, 10:00", UnknownCommandException.class);
        testFailException("a task; from 2015-2-00, 10:00", UnknownCommandException.class);
        testFailException("a task; from 2015_1_32, 10:00", UnknownCommandException.class);
        testFailException("a task; from 2015_00_1, 10:00", UnknownCommandException.class);
        testFailException("a task; from -15_00_1, 10:00", UnknownCommandException.class);

        // @yijin Currently failing
        testFailException("a task; from -15_00_1, 10:00", UnknownCommandException.class);
        testFailException("a task; from 2015_2_-1, 10:00", UnknownCommandException.class);
    }

    @Test
    public void DateUnderscore() {
        LocalDateTime testDate;
        LocalDateTime assertDate;

        testPass("a task; from 2015_1_3, 10:00 to 2015_1_5, 10:01");
        TasksBag bag = logic.getTaskBag();
        Task task = bag.getTask(0);

        assertDate = LocalDateTime.of(2015, 1, 3, 10, 0);
        testDate = LocalDateTime.ofInstant(task.getStart().toInstant(), ZoneId.systemDefault());
        System.out.println(testDate);
        System.out.println(assertDate);
        Assert.assertTrue(testDate.equals(assertDate));

        assertDate = LocalDateTime.of(2015, 1, 5, 10, 1);
        testDate = LocalDateTime.ofInstant(task.getEnd().toInstant(), ZoneId.systemDefault());
        System.out.println(testDate);
        System.out.println(assertDate);
        Assert.assertTrue(testDate.equals(assertDate));
    }

    @Test
    public void DateDot() {
        LocalDateTime testDate;
        LocalDateTime assertDate;

        testPass("a task; from 2015.1.2, 10:00 to 2015.1.4, 10:01");
        TasksBag bag = logic.getTaskBag();
        Task task = bag.getTask(0);

        assertDate = LocalDateTime.of(2015, 1, 2, 10, 0);
        testDate = LocalDateTime.ofInstant(task.getStart().toInstant(), ZoneId.systemDefault());
        System.out.println(testDate);
        System.out.println(assertDate);
        Assert.assertTrue(testDate.equals(assertDate));

        assertDate = LocalDateTime.of(2015, 1, 4, 10, 1);
        testDate = LocalDateTime.ofInstant(task.getEnd().toInstant(), ZoneId.systemDefault());
        System.out.println(testDate);
        System.out.println(assertDate);
        Assert.assertTrue(testDate.equals(assertDate));
    }

    @Test
    public void DateForwardSlash() {
        LocalDateTime testDate;
        LocalDateTime assertDate;

        testPass("a task; from 2015/1/3, 10:00 to 2015/1/5, 10:01");
        TasksBag bag = logic.getTaskBag();
        Task task = bag.getTask(0);

        assertDate = LocalDateTime.of(2015, 1, 3, 10, 0);
        testDate = LocalDateTime.ofInstant(task.getStart().toInstant(), ZoneId.systemDefault());
        System.out.println(testDate);
        System.out.println(assertDate);
        Assert.assertTrue(testDate.equals(assertDate));

        assertDate = LocalDateTime.of(2015, 1, 5, 10, 1);
        testDate = LocalDateTime.ofInstant(task.getEnd().toInstant(), ZoneId.systemDefault());
        System.out.println(testDate);
        System.out.println(assertDate);
        Assert.assertTrue(testDate.equals(assertDate));
    }

    @Test
    public void DateBackSlash() {
        LocalDateTime testDate;
        LocalDateTime assertDate;

        testPass("a task; from 2015\\1\\3, 10:00 to 2015\\1\\5, 10:01");
        TasksBag bag = logic.getTaskBag();
        Task task = bag.getTask(0);

        assertDate = LocalDateTime.of(2015, 1, 3, 10, 0);
        testDate = LocalDateTime.ofInstant(task.getStart().toInstant(), ZoneId.systemDefault());
        System.out.println(testDate);
        System.out.println(assertDate);
        Assert.assertTrue(testDate.equals(assertDate));

        assertDate = LocalDateTime.of(2015, 1, 5, 10, 1);
        testDate = LocalDateTime.ofInstant(task.getEnd().toInstant(), ZoneId.systemDefault());
        System.out.println(testDate);
        System.out.println(assertDate);
        Assert.assertTrue(testDate.equals(assertDate));
    }

    @Test
    public void DateColon() {
        LocalDateTime testDate;
        LocalDateTime assertDate;
        testPass("a task; from 2015:10:1, 10:00 to 2015:10:1, 10:01");
        TasksBag bag = logic.getTaskBag();
        Task task = bag.getTask(0);

        assertDate = LocalDateTime.of(2015, 10, 1, 10, 0);
        testDate = LocalDateTime.ofInstant(task.getStart().toInstant(), ZoneId.systemDefault());
        System.out.println(testDate);
        System.out.println(assertDate);
        Assert.assertTrue(testDate.equals(assertDate));

        assertDate = LocalDateTime.of(2015, 10, 1, 10, 1);
        testDate = LocalDateTime.ofInstant(task.getEnd().toInstant(), ZoneId.systemDefault());
        System.out.println(testDate);
        System.out.println(assertDate);
        Assert.assertTrue(testDate.equals(assertDate));
    }

    /*
     * Below are helper functions to ease testing
     */
    private void testPass(String passCommand) {
        try {
            logic.executeCommand(passCommand);
        } catch (LogicException e) {
            Assert.fail("Should not thrown Exception for: " + passCommand + e.toString());
        }
    }

    private void testFailException(String failCommand, Class<? extends LogicException> whatException) {
        try {
            logic.executeCommand(failCommand);
        } catch (LogicException e) {
            Assert.assertEquals(whatException, e.getClass());
            if (e.getClass().equals(whatException)) {
                return;
            }
            Assert.fail("Should have thrown " + whatException.getName() + " for: " + failCommand);
        }
        Assert.fail("Should have thrown " + whatException.getName() + " for: " + failCommand);
    }

    private void init() {
        /*
        File tempFd = new File(JSON_LOC_TEMP);
        File fd = new File(JSON_LOC_DEFAULT);

        
        try {
            //Files.copy(fd.toPath(), tempFd.toPath(), StandardCopyOption.REPLACE_EXISTING);
            //fd.delete();
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        String s = Configuration.getInstance().getUsrFileDirectory();
        while (logic.initData(s) == false) {
            // Failed to load data, query user to give filename
            s = "NEW_LOCATION.txt";
        }
        */
        logic = new Logic();
        logic.init();
        logic.setStorage(new StorageStub());

        
    }

    private void cleanUp() {
        logic.close();
        File fd = new File(JSON_LOC_DEFAULT);
        File tempFd = new File(JSON_LOC_TEMP);
        Date timeStamp = new Date();

        File finalDir = new File(JSON_LOC_FINAL);
        if(finalDir.exists() == false){
           finalDir.mkdir();
        }
        
        File finalLocFd = new File(JSON_LOC_FINAL + timeStamp.getTime() + ".json");
        
        try {
            Files.copy(fd.toPath(), finalLocFd.toPath(), StandardCopyOption.REPLACE_EXISTING);
            Files.copy(tempFd.toPath(), fd.toPath(), StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
###### src\logic\MarkAction.java
``` java
package logic;

import common.Task;
import common.TasksBag;
import common.Utilities;
import logic.exceptions.AlreadyMarkedException;
import logic.exceptions.IllegalAccessCommandException;
import logic.exceptions.LogicException;
import parser.commands.CommandData;
import storage.StorageInterface;

public class MarkAction implements UndoableAction {

    private static final String USR_MSG_INDEX_ERR = "Provided index not on list.";
    private static final String USR_MSG_MARK_OK = "Marked %1$s!";
    private static final String USR_MSG_MARK_FAIL = "Already marked %1$s!";
    private static final String USR_MSG_MARK_UNDO = "Undo mark %1$s!";
    
    private static final String USR_MSG_MARK_WARNING_STORE_FAIL = "Fail to update the storage file!";
    
    private CommandData cCommand;
    private TasksBag cCurBag;    
    private TasksBag cIntBag;
    private StorageInterface cStore;
    private Task cWhichTask;
    private boolean cUpdateSuccess;
    
    public MarkAction(CommandData command, TasksBag internalBag, StorageInterface stor) throws IllegalAccessCommandException {
        
        cCommand = command;
        cCurBag = internalBag.getFilteredView();
        cIntBag = internalBag;
        cStore = stor;
        
        int UID = cCommand.getTaskUID();

        if (UID <= 0) {
            throw new IllegalAccessCommandException(USR_MSG_INDEX_ERR);
        }

        if (UID > cCurBag.size()) {
            throw new IllegalAccessCommandException(USR_MSG_INDEX_ERR);
        }

        // UID - 1 to get  array index
        UID -= 1;
        
        cWhichTask = cCurBag.getTask(UID);
    }

    @Override
    public CommandFeedback execute() throws LogicException {
        String formattedString;
        String warningString = "";
        // Should not mark again if it is already marked.
        // Does not go into undo queue if already marked.
        if(cWhichTask.isCompleted()){ 
            formattedString = Utilities.formatString(USR_MSG_MARK_FAIL, cWhichTask.getName());
            throw new AlreadyMarkedException(formattedString);
        } else { 
            cWhichTask.setComplete(true);
            cUpdateSuccess = cStore.save(cWhichTask);
            
            if (!cUpdateSuccess) {
            	warningString = USR_MSG_MARK_WARNING_STORE_FAIL;
            }
        }
        
        formattedString =  Utilities.formatString(USR_MSG_MARK_OK, cWhichTask.getName());
        CommandFeedback fb = new CommandFeedback(cCommand, cIntBag, formattedString, warningString);

        return fb;
    }

    @Override
    public CommandFeedback undo() {
        assert cWhichTask != null;
        
        String warningString = "";

        cWhichTask.setComplete(false);
        cUpdateSuccess = cStore.save(cWhichTask);
        
        if (!cUpdateSuccess) {
        	warningString = USR_MSG_MARK_WARNING_STORE_FAIL;
        }
        
        String formattedString =  Utilities.formatString(USR_MSG_MARK_UNDO, cWhichTask.getName());
        return new CommandFeedback(cCommand, cIntBag, formattedString, warningString);
    }

    @Override
    public CommandFeedback redo() throws LogicException {
        return execute();
    }
}
```
###### src\logic\SearchAction.java
``` java
package logic;

import common.TasksBag;
import common.Utilities;
import logic.exceptions.LogicException;
import parser.commands.CommandData;

public class SearchAction implements Action {
    private static final String USR_MSG_SEARCH_COMPLETE = "Search for %1$s";

    private CommandData cCommand;
    private TasksBag cBag;
    private String cKeyword;

    public SearchAction(CommandData command, TasksBag internalBag) throws LogicException {
        cCommand = command;
        cBag = internalBag;
        cKeyword = command.getText();
    }

    @Override
    public CommandFeedback execute() throws LogicException {
        String formattedString;

        cBag.setSearchState(cKeyword);
        formattedString = Utilities.formatString(USR_MSG_SEARCH_COMPLETE, cKeyword);

        return new CommandFeedback(cCommand, cBag, formattedString);
    }

}
```
###### src\logic\StorageStub.java
``` java
package logic;

import common.Task;
import common.TasksBag;
import storage.StorageInterface;

/**
 * Simulate a storage and returns true for every methods
 */
public class StorageStub implements StorageInterface {

    @Override
    public void init() {
    }

    @Override
    public boolean load(TasksBag c) {
        return true;
    }

    @Override
    public boolean save(Task c) {
        return true;
    }

    @Override
    public boolean delete(Task c) {
        return true;
    }

    @Override
    public void moveFileTo(String destination) {
        
    }

    @Override
    public void close() {
    }

}
```
###### src\logic\ThemeChangeAction.java
``` java
public class ThemeChangeAction implements Action {
    private static final String USR_MSG_THEME_NIGHT = "Switched to night theme~!";
    private static final String USR_MSG_THEME_DAY = "Switched to day theme~!";
    private CommandData cCommand;
    private TasksBag cBag;
    private ConfigurationInterface cConfig;
    private CelebiViewController.Skin cSkin;


    public ThemeChangeAction(CommandData comd, TasksBag bag) {
    	cConfig = Configuration.getInstance();
        cCommand = comd;
        cBag = bag;
        cSkin = cCommand.getTheme();
        assert cSkin != null;
    }

    @Override
    public Feedback execute() throws LogicException {
        String msg = "";
        String warningMsg = "";
        switch (cSkin) {
            case DAY:
                msg = USR_MSG_THEME_DAY;
                break;
            case NIGHT:
                msg = USR_MSG_THEME_NIGHT;
                break;
            default:
                break;

        }

        warningMsg = processWarning();

        CommandFeedback fb = new CommandFeedback(cCommand, cBag, msg, warningMsg);
        return fb;
    }

    private String processWarning() {
        String warningMsg = "";
        cConfig.setSkin(cSkin.toString());
        return warningMsg;
    }

}
```
###### src\logic\UndoableAction.java
``` java
package logic;

import logic.exceptions.LogicException;

public interface UndoableAction extends Action {
    
    public Feedback undo();

    public Feedback redo() throws LogicException;
}
```
###### src\logic\UnmarkAction.java
``` java
package logic;

import common.Task;
import common.TasksBag;
import common.Utilities;
import logic.exceptions.AlreadyUnmarkedException;
import logic.exceptions.IllegalAccessCommandException;
import logic.exceptions.LogicException;
import parser.commands.CommandData;
import storage.StorageInterface;

public class UnmarkAction implements UndoableAction {

    private static final String USR_MSG_INDEX_ERR = "Provided index not on list.";
    private static final String USR_MSG_UNMARK_OK = "Unmarked %1$s!";
    private static final String USR_MSG_UNMARK_FAIL = "Already unmarked %1$s!";
    private static final String USR_MSG_UNMARK_UNDO = "Undo unmarked %1$s!";
    
    private static final String USR_MSG_UNMARK_WARNING_STORE_FAIL = "Fail to update the storage file!";

    private CommandData cCommand;
    private TasksBag cCurBag;
    private TasksBag cIntBag;
    private StorageInterface cStore;
    private Task cWhichTask;
    private boolean cUpdateSuccess;

    public UnmarkAction(CommandData command, TasksBag internalBag, StorageInterface stor) throws IllegalAccessCommandException {
        cCommand = command;
        cCurBag = internalBag.getFilteredView();
        cIntBag = internalBag;
        cStore = stor;

        int UID = cCommand.getTaskUID();

        if (UID <= 0) {
            throw new IllegalAccessCommandException(USR_MSG_INDEX_ERR);
        }

        if (UID > cCurBag.size()) {
            throw new IllegalAccessCommandException(USR_MSG_INDEX_ERR);
        }

        // UID - 1 to get array index
        UID -= 1;

        cWhichTask = cCurBag.getTask(UID);
    }

    @Override
    public CommandFeedback execute() throws LogicException {
        String formattedString;
        String warningString = "";

        // Should not unmark again if it is already unmarked.
        // Does not go into undo queue if already unmarked.
        if (cWhichTask.isCompleted() == false) {
            formattedString = Utilities.formatString(USR_MSG_UNMARK_FAIL, cWhichTask.getName());
            throw new AlreadyUnmarkedException(formattedString);
        } else {
            cWhichTask.setComplete(false);
            cUpdateSuccess = cStore.save(cWhichTask);
        }
        
        if (!cUpdateSuccess) {
        	warningString = USR_MSG_UNMARK_WARNING_STORE_FAIL;
        }

        formattedString = Utilities.formatString(USR_MSG_UNMARK_OK, cWhichTask.getName());
        CommandFeedback fb = new CommandFeedback(cCommand, cIntBag, formattedString, warningString);

        return fb;
    }

    @Override
    public CommandFeedback undo() {
        assert cWhichTask != null;

        String warningString = "";
        
        cWhichTask.setComplete(true);
        cUpdateSuccess = cStore.save(cWhichTask);
        
        if (!cUpdateSuccess) {
        	warningString = USR_MSG_UNMARK_WARNING_STORE_FAIL;
        }

        String formattedString = Utilities.formatString(USR_MSG_UNMARK_UNDO, cWhichTask.getName());
        return new CommandFeedback(cCommand, cIntBag, formattedString, warningString);
    }

    @Override
    public CommandFeedback redo() throws LogicException {
        return execute();
    }
}
```
###### src\logic\UpdateAction.java
``` java
package logic;

import common.Task;
import common.TasksBag;
import common.Utilities;
import javafx.collections.ObservableList;
import logic.exceptions.IllegalAccessCommandException;
import logic.exceptions.IntegrityCommandException;
import logic.exceptions.InvalidDateException;
import logic.exceptions.LogicException;
import parser.commands.CommandData;
import storage.StorageInterface;

public class UpdateAction implements UndoableAction {
    private static final String USR_MSG_UPDATE_OOB = "Provided index not on list.";
    private static final String USR_MSG_UPDATE_STARTDATE_OK = "Updated start date of %1$s!";
    private static final String USR_MSG_UPDATE_STARTDATE_INVALID = "Failed to update! Start date is earlier than of end date!";
    private static final String USR_MSG_UPDATE_ENDDATE_OK = "Updated end date of %1$s!";
    private static final String USR_MSG_UPDATE_ENDDATE_INVALID = "Failed to update! End date is earlier than of start date!";
    private static final String USR_MSG_UPDATE_NAME_OK = "Updated name of %1$s!";
    private static final String USR_MSG_UPDATE_UNDO = "Undo update %1$s!";

    private static final String USR_MSG_UPDATE_ERROR_LONG_NAME = "Failed to update! Your task name is too long! Keep it "
            + "to less than 50 characters.";
    private static final String USR_MSG_UPDATE_CLASH_WARNING_SINGLE = "Task clashes with %1$s!";
    private static final String USR_MSG_UPDATE_CLASH_WARNING_MANY = "Task clashes with %1$s and %2$s more!";
    private static final String USR_MSG_UPDATE_WARNING_STORE_FAIL = "Fail to update the storage file!";
    private static final int NAME_LIMIT = 50; // Hard limit for user's max char
    
    private CommandData cCommand;
    private TasksBag cCurBag;
    private TasksBag cIntBag;
    private StorageInterface cStore;
    private Task cWhichTask;
    private Task cOldTask;
    private boolean cUpdateSuccess;

    public UpdateAction(CommandData command, TasksBag bag, StorageInterface stor) throws LogicException {
        cCommand = command;
        cCurBag = bag.getFilteredView();
        cIntBag = bag;
        cStore = stor;

        int UID = cCommand.getTaskUID();

        // Lower bound
        if (UID <= 0) {
            throw new IllegalAccessCommandException(USR_MSG_UPDATE_OOB);
        }

        // Upper bound
        if (UID > cCurBag.size()) {
            throw new IllegalAccessCommandException(USR_MSG_UPDATE_OOB);
        }

        // UID - 1 to get actual array mapping
        UID -= 1;

        cWhichTask = cCurBag.getTask(UID);

        verifyUpdateData();

        cOldTask = cWhichTask.clone();
    }

    private void verifyUpdateData() throws LogicException {
        boolean isValid;
        switch (cCommand.getTaskField()) {
            case DATE_END:
                // Check date if end date is valid to determine if task should
                // be updated.
            	
            	// allow null values to change from event->startonly or deadline->float
                if (cCommand.getEnd() == null) {
                	break;
                }

                isValid = Utilities.verifyDate(cWhichTask.getStart(), cCommand.getEnd());
                if (isValid == false) {
                    throw new InvalidDateException(USR_MSG_UPDATE_ENDDATE_INVALID);
                }

                break;
            case DATE_START:
                // Check date if start date is valid to determine if task should
                // be updated.
            	
            	// allow null values to change from event->deadline or startonly-float
                if (cCommand.getStart() == null) {
                	break;
                }

                isValid = Utilities.verifyDate(cCommand.getStart(), cWhichTask.getEnd());
                if (isValid == false) {
                    throw new InvalidDateException(USR_MSG_UPDATE_STARTDATE_INVALID);
                }

                break;
            case NAME:
                assert cCommand.getText() != null;
                validateTaskName(cCommand.getText());
                break;
            default:
                break;

        }
    }
    @Override
    public CommandFeedback execute() throws LogicException {
        Task toBeUpdated = cWhichTask;
        CommandFeedback fb;
        String formattedString;
        String warningString;
        
        switch (cCommand.getTaskField()) {
            case DATE_END:

                toBeUpdated.setEnd(cCommand.getEnd());
                cUpdateSuccess = cStore.save(toBeUpdated);
                warningString = processWarningMsg();
                
                formattedString = Utilities.formatString(USR_MSG_UPDATE_ENDDATE_OK, toBeUpdated.getName());
                fb = new CommandFeedback(cCommand, cIntBag, formattedString, warningString);

                return fb;
            case DATE_START:

                toBeUpdated.setStart(cCommand.getStart());
                cUpdateSuccess = cStore.save(toBeUpdated);
                warningString = processWarningMsg();
                
                formattedString = Utilities.formatString(USR_MSG_UPDATE_STARTDATE_OK, toBeUpdated.getName());
                fb = new CommandFeedback(cCommand, cIntBag, formattedString, warningString);
                return fb;

            case NAME:

                toBeUpdated.setName(cCommand.getText());
                cUpdateSuccess = cStore.save(toBeUpdated);
                warningString = processWarningMsg();
                
                formattedString = Utilities.formatString(USR_MSG_UPDATE_NAME_OK, toBeUpdated.getName());
                fb = new CommandFeedback(cCommand, cIntBag, formattedString, warningString);

                return fb;
            default:
                assert false : cCommand.getTaskField();
        }
        return null;

    }

    @Override
    public CommandFeedback undo() {
        Task toBeUpdated = cWhichTask;
        CommandFeedback fb;
        String formattedString;
        String warningString = "";

        switch (cCommand.getTaskField()) {
            case DATE_END:

                toBeUpdated.setEnd(cOldTask.getEnd());
                cUpdateSuccess = cStore.save(toBeUpdated);
                warningString = getWarningString();

                formattedString = Utilities.formatString(USR_MSG_UPDATE_UNDO, toBeUpdated.getName());
                fb = new CommandFeedback(cCommand, cIntBag, formattedString, warningString);

                return fb;
            case DATE_START:

                toBeUpdated.setStart(cOldTask.getStart());
                cUpdateSuccess = cStore.save(toBeUpdated);
                warningString = getWarningString();

                formattedString = Utilities.formatString(USR_MSG_UPDATE_UNDO, toBeUpdated.getName());
                fb = new CommandFeedback(cCommand, cIntBag, formattedString, warningString);
                return fb;

            case NAME:

                toBeUpdated.setName(cOldTask.getName());
                cUpdateSuccess = cStore.save(toBeUpdated);
                warningString = getWarningString();

                formattedString = Utilities.formatString(USR_MSG_UPDATE_UNDO, toBeUpdated.getName());
                fb = new CommandFeedback(cCommand, cIntBag, formattedString, warningString);

                return fb;
            default:
                assert false : cCommand.getTaskField();
        }
        return null;
    }

    @Override
    public CommandFeedback redo() throws LogicException {
        return execute();
    }
    
    private String processWarningMsg() {
        String warningString = "";
        String formatted;
        ObservableList<Task> clashList = cIntBag.findClashesWithIncomplete(cWhichTask);
        
        if (!cUpdateSuccess) {
        	warningString = Utilities.appendWarningStrings(warningString, USR_MSG_UPDATE_WARNING_STORE_FAIL);
        }
        
        if(clashList == null || clashList.size() == 0){
            return warningString;
        }
        
        Task firstTask = clashList.get(0);
        if(clashList.size() > 1){
            int noOfOtherClashes = clashList.size() - 1;
            formatted = Utilities.formatString(USR_MSG_UPDATE_CLASH_WARNING_MANY, firstTask.getName(), noOfOtherClashes);
            warningString = Utilities.appendWarningStrings(warningString, formatted);
        } else {            
        	formatted = Utilities.formatString(USR_MSG_UPDATE_CLASH_WARNING_SINGLE, firstTask.getName());
        	warningString = Utilities.appendWarningStrings(warningString, formatted);
        }
        return warningString;
    }

    private void validateTaskName(String name) throws IntegrityCommandException {
        if (name.length() > NAME_LIMIT) {
            throw new IntegrityCommandException(USR_MSG_UPDATE_ERROR_LONG_NAME);
        }
    }
    
```
###### src\logic\ViewAction.java
``` java
package logic;

import common.TasksBag;
import common.TasksBag.ViewType;
import parser.commands.CommandData;

/**
 * Changes the state of the internal taskbags to given sort state Undo sets the
 * internal bag state to previous state
 */
public class ViewAction implements Action {
    private static final String USR_MSG_VIEW_COMPLETE = "Switching view to completed tasks";
    private static final String USR_MSG_VIEW_INCOMPLETE = "Switching view to incompleted tasks";
    private static final String USR_MSG_VIEW_TODAY = "Switching view to today tasks";

    private CommandData cCommand;
    private TasksBag cBag;
    private ViewType cViewBy;

    public ViewAction(CommandData command, TasksBag internalBag) {
        cCommand = command;
        cBag = internalBag;
        cViewBy = cCommand.getViewType();
    }

    @Override
    public CommandFeedback execute() {
        String msg = "";
        switch (cViewBy) {
            case COMPLETED:
                msg = USR_MSG_VIEW_COMPLETE;
                cBag.setView(ViewType.COMPLETED);
                break;
            case INCOMPLETE:
                msg = USR_MSG_VIEW_INCOMPLETE;
                cBag.setView(ViewType.INCOMPLETE);
                break;
            case DEFAULT:
                msg = USR_MSG_VIEW_TODAY;
                cBag.setView(ViewType.DEFAULT);
                break;
            default:
                assert false;
                break;

        }
        return new CommandFeedback(cCommand, cBag, msg);
    }

}
```
###### src\logic\ViewToggleAction.java
``` java
public class ViewToggleAction implements Action {
    private static final String USR_MSG_VIEW_COMPLETE = "Switching view to completed tasks";
    private static final String USR_MSG_VIEW_INCOMPLETE = "Switching view to incompleted tasks";
    private static final String USR_MSG_VIEW_TODAY = "Switching view to today tasks";

    private TasksBag cBag;
    private KeyCode cKey;

    public ViewToggleAction(TasksBag bag, KeyCode key) {
        cBag = bag;
        cKey = key;
    }

    @Override
    public KeyEventFeedback execute() throws LogicException {
        KeyEventFeedback fb;
        ViewType viewState;
        String msg = "";

        cBag.toggleView();
        viewState = cBag.getView();
        
        switch (viewState) {
            case COMPLETED:
                msg = USR_MSG_VIEW_COMPLETE;
                break;

            case INCOMPLETE:
                msg = USR_MSG_VIEW_INCOMPLETE;
                break;

            case DEFAULT:
                msg = USR_MSG_VIEW_TODAY;
                break;
        }

        fb = new KeyEventFeedback(cBag, cKey, msg);
        return fb;
    }

}
```
###### src\ui\UI.java
``` java
    /**
     * Pass the key event to logic
     */
    @Override
    public void passKeyEvent(KeyCode whichKey) {
        controller.clearCommand();
        controller.clearFeedback();

        String usrCmd = Utilities.formatString(UI_TXT_TABEVENT);
        controller.showFeedback(usrCmd);

        KeyEventFeedback cmd = null;
        String usrMsg = "";
        try {
            cmd = logic.executeKeyEvent(whichKey);
            cb = cmd.getcBag();
            display(cb);
            usrMsg = Utilities.formatString(UI_TXT_FEEDBACK, cmd.getMsg());
            controller.showFeedback(usrMsg);

        } catch (LogicException e) {

            usrMsg = Utilities.formatString(UI_TXT_FEEDBACK, e.cMsg);
            controller.showFeedback(usrMsg);
        } catch (Exception e) {
            log.severe(e.toString());
        }
    }
}
```
###### src\ui\view\CelebiViewController.java
``` java
    /**
     * To check if the first word is a keyword that activates tool tip
     * @param firstWord
     */
    private void checkToolTip(String firstWord) {
    	if (firstWord == null) {
    		return; // catches command input field clearing change
    	}
        // show the tool-tip
        String toolTip = HelpStrings.getHelpToolTip(firstWord);
        if (toolTip == null) {
            //popupLabel.setText("");
            popupFader.fadeOut();
        } else {
            
            //toolTip = Utilities.textSpacer(toolTip, 1);
            popupLabel.setText(toolTip);
            popupFader.fadeIn();
        }
    }

```
###### src\ui\view\LabelFader.java
``` java
package ui.view;

import javafx.animation.FadeTransition;
import javafx.scene.control.Label;
import javafx.util.Duration;

public class LabelFader {

    private enum State {
        ON, OFF
    }

    private Label cLabel;
    private State cState;
    private FadeTransition fadeIn;

    public LabelFader(Label label) {
        cLabel = label;
        label.setVisible(false);
        cState = State.OFF;

        fadeIn = new FadeTransition(Duration.millis(500));
        initFadeAnimations();
    }

    public void fadeIn() {
        if (cState == State.OFF) {
            cLabel.setVisible(true);
        	fadeIn.setRate(1);
            fadeIn.play();
            cState = State.ON;
        }
    }

    public void fadeOut() {
        if (cState == State.ON) {
            fadeIn.setRate(-1);
            fadeIn.play();
            cState = State.OFF;
        }
    }

    private void initFadeAnimations() {
        fadeIn.setNode(cLabel);

        fadeIn.setFromValue(0.0);
        fadeIn.setToValue(1.0);
        fadeIn.setCycleCount(0);
        fadeIn.setAutoReverse(false);
    }
}
```
