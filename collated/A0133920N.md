# A0133920N
###### src\common\Configuration.java
``` java

/*
 * @class: Configuration
 * Configuration represents the userâ€™s settings for Celebi. 
 * This class directly maps to a file named config.json. 
 * Users can change their settings through certain commands, 
 * and this class will write the settings into config.json. 
 * It also reads from config.json to load user settings. 
 * If it fails to load settings, this class will reset everything 
 * to default settings, which is stored inside as static data.
 */
package common;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.Writer;
import java.nio.file.Paths;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;

import org.json.simple.JSONObject;
import org.json.simple.JSONValue;

import parser.Aliases;
import parser.AliasesImpl;
import parser.commands.CommandData;

import static ui.view.CelebiViewController.Skin;

public class Configuration implements ConfigurationInterface {
	private static final String CURRENT_LOCATION = Paths.get("").toAbsolutePath().toString();
    private static final String CONFIG_FILE_DIR = CURRENT_LOCATION + File.separator +"config.json";
    
    // the key of different properties
    private static final String KEY_STORAGE_LOCATION = "STORAGE_LOCATION";
    private static final String KEY_DEFAULT_START_TIME = "DEFAULT_START_TIME";
    private static final String KEY_DEFAULT_END_TIME = "DEFAULT_END_TIME";
    private static final String KEY_ALIAS_MAPPINGS = "ALIAS_MAPPINGS";
    private static final String KEY_SKIN = "SKIN";
    
    // possible skins
    private static final String VALUE_SKIN_DAY = Skin.DAY.name();
    private static final String VALUE_SKIN_NIGHT = Skin.NIGHT.name();
    
    // default values
    private static final String DEFAULT_VALUE_STORAGE_LOCATION = CURRENT_LOCATION;
    private static final String DEFAULT_VALUE_DEFAULT_START_TIME = "08:00";
    private static final String DEFAULT_VALUE_DEFAULT_END_TIME = "23:59";
    private static final String DEFAULT_VALUE_SKIN = VALUE_SKIN_DAY;
    
    // messages used to write into logs
    private static final String MESSAGE_INVALID_STORAGE_LOCATION = "%1$s is not a valid path";
    private static final String MESSAGE_INVALID_DEFAULT_START_TIME = "Start time %1$s is invalid";
    private static final String MESSAGE_INVALID_DEFAULT_END_TIME = "End time %1$s is invalid";
    private static final String MESSAGE_INVALID_ALIAS_MAP = "Corrupted Map (format or values)%s";
    private static final String MESSAGE_INVALID_SKIN = "Skin %1s does not exist";
        
    private static Configuration instance = null;

    private File configFile;
    private Scanner configReader;
    private Writer configWriter;
    private String configStorageLocation, configDefaultStartTime, configDefaultEndTime, configSkin;
    private Map<String, String> configUserCmdAliases;
    private Aliases ALIASES;

    // Apply Singleton Pattern
    public static ConfigurationInterface getInstance() {
        if (instance == null) {
            instance = new Configuration();
        }
        return instance;
    }
    
    private Configuration() {
        findConfigFile();
        readProperties();
    }

    // Getters
    
    @Override
    /*
     * @see common.ConfigurationInterface#getDefaultUsrFileDirectory()
     */
    public String getDefaultUsrFileDirectory() {
    	return DEFAULT_VALUE_STORAGE_LOCATION;
    }

    @Override
    /*
     * @see common.ConfigurationInterface#getUsrFileDirectory()
     */
    public String getUsrFileDirectory() {
    	assert(configStorageLocation != null);
        return configStorageLocation;
    }

    @Override
    /*
     * @see common.ConfigurationInterface#getDefaultStartTime()
     */
    public Time getDefaultStartTime() {
    	assert(isValidTime(configDefaultStartTime));
        return new Time(configDefaultStartTime);
    }

    @Override
    /*
     * @see common.ConfigurationInterface#getDefaultEndTime()
     */
    public Time getDefaultEndTime() {
    	assert(isValidTime(configDefaultEndTime));
        return new Time(configDefaultEndTime);
    }
    
    @Override
    /*
     * @see common.ConfigurationInterface#getSkin()
     */
    public String getSkin() {
    	assert(isValidSkin(configSkin));
    	return configSkin;
    }

```
###### src\common\Configuration.java
``` java
    @Override
    /*
     * @see common.ConfigurationInterface#setStorageLocation(java.lang.String)
     */
    public void setStorageLocation(String newDir) {
    	assert(newDir != null);
		configStorageLocation = newDir;
		
		// write to the configuration file
        writeBack();
        Log.log("Storage file moved to " + newDir, this.getClass());
    }

    @Override
    /*
     * @see common.ConfigurationInterface#setDefaultStartTime(java.lang.String)
     */
    public void setDefaultStartTime(String newTime) {
    	if (isValidTime(newTime)) {
    		configDefaultStartTime = newTime;
    		
    		// write to the configuration file
            writeBack();
            Log.log("Default start time set to " + newTime, this.getClass());
    	} 
    }
    
    @Override
    /*
     * @see common.ConfigurationInterface#setDefaultEndTime(java.lang.String)
     */
    public void setDefaultEndTime(String newTime) {
    	if (isValidTime(newTime)) {
    		configDefaultEndTime = newTime;
    		
    		// write to the configuration file
            writeBack();
            Log.log("Default end time set to " + newTime, this.getClass());
    	}
    }
    
    @Override
    /*
     * @see common.ConfigurationInterface#setSkin(java.lang.String)
     */
    public void setSkin(String skin) {
    	if (isValidSkin(skin)) {
    		configSkin = skin;
    		writeBack();
    		Log.log("Theme set to " + configSkin, this.getClass());
    	}
    }
    
```
###### src\common\Configuration.java
``` java
    private void resetAll() {
        // set all properties to default value
    	configStorageLocation = DEFAULT_VALUE_STORAGE_LOCATION;
    	configDefaultStartTime = DEFAULT_VALUE_DEFAULT_START_TIME;
    	configDefaultEndTime = DEFAULT_VALUE_DEFAULT_END_TIME;
    	configSkin = DEFAULT_VALUE_SKIN;
    	configUserCmdAliases = new LinkedHashMap<String, String>();

        // write to the configuration file
        writeBack();
    }
    
    public void resetStorageLocation() {
    	setStorageLocation(DEFAULT_VALUE_STORAGE_LOCATION);
    }
    
    private void resetDefaultStartTime() {
    	setDefaultStartTime(DEFAULT_VALUE_DEFAULT_START_TIME);
    }
    
    private void resetDefaultEndTime() {
    	setDefaultEndTime(DEFAULT_VALUE_DEFAULT_END_TIME);
    }
    
    private void resetSkin() {
    	setSkin(DEFAULT_VALUE_SKIN);
    }
    
```
###### src\common\Configuration.java
``` java
    private boolean isValidTime(String str) {
    	if (str == null) {
    		return false;
    	}
    	
    	Time t = new Time(str);
    	return t.isValid();
    }
    
    private boolean isValidSkin(String str) {
    	if (str == null) {
    		return false;
    	}
    	
    	String upper = str.toUpperCase();
    	
    	return upper.equals(VALUE_SKIN_DAY) || upper.equals(VALUE_SKIN_NIGHT);
    }

    // Write error into log
    private void logError(String invalidMsg, String arg) {
    	String formatted = Utilities.formatString(invalidMsg, arg);
    	Log.log(formatted);
    }
    
    // Write the current status into configuration file
    @SuppressWarnings("unchecked")
	private void writeBack() { 
    	try {
    		JSONObject configJson = new JSONObject();
            configJson.put(KEY_STORAGE_LOCATION, configStorageLocation);
            configJson.put(KEY_DEFAULT_START_TIME, configDefaultStartTime);
            configJson.put(KEY_DEFAULT_END_TIME, configDefaultEndTime);
            configJson.put(KEY_SKIN, configSkin);
            //TODO new alias code
            configJson.put(KEY_ALIAS_MAPPINGS, configUserCmdAliases);

            configWriter = new BufferedWriter(new FileWriter(CONFIG_FILE_DIR));
            String text = JSONValue.toJSONString(configJson);
            configWriter.write(text);
            configWriter.close();
            configWriter = null;
    	} catch (Exception e) {
    		Log.log("Fail to write user settings");
    	}
    }
    
    /*
     * Possible errors and solutions: 
     * 1. configuration file not found -> recreate write in default settings
     * 2. configuration file cannot be parsed -> rewrite in default settings
     * 3. configuration file does not have certain property -> set to default value of the property
     */
    private void findConfigFile() {
    	try {
    		configFile = new File(CONFIG_FILE_DIR);

            if (!configFile.exists()) {
                configFile.createNewFile();
                resetAll();
            }
    	} catch (Exception e) {
    		Log.log("Fail to create configuration file", this.getClass());
    		resetAll();
    	}
    }

	@SuppressWarnings({ "unchecked", "rawtypes" })
	/*
	 * Read the properties from config file one by one,
	 * also check whether the data parsed are valid or not,
	 * if encounter any invalid data, reset it to default value
	 */
	private void readProperties() {
        try {
        	assert(configFile != null);
        	String plainText = "";
        	
        	configReader = new Scanner(configFile);
        	configReader.useDelimiter("\\Z");
            
            if (configReader.hasNext()) {
                plainText = configReader.next();
            }
            
            configReader.close();

            JSONObject parsedResult = (JSONObject) JSONValue.parse(plainText);
            if (parsedResult == null) {
            	resetAll();
            	return;
            }

            configStorageLocation = (String) parsedResult.get(KEY_STORAGE_LOCATION);
            if (configStorageLocation == null) {
            	resetStorageLocation();
            	logError(MESSAGE_INVALID_STORAGE_LOCATION, configStorageLocation);
            } 
            
            configDefaultStartTime = (String) parsedResult.get(KEY_DEFAULT_START_TIME);
            if (!isValidTime(configDefaultStartTime)) {
            	resetDefaultStartTime();
            	logError(MESSAGE_INVALID_DEFAULT_START_TIME, configDefaultStartTime);
            } 
            
            configDefaultEndTime = (String) parsedResult.get(KEY_DEFAULT_END_TIME);
            if (!isValidTime(configDefaultEndTime)) {
            	resetDefaultEndTime();
            	logError(MESSAGE_INVALID_DEFAULT_END_TIME, configDefaultEndTime);
            } 

            configUserCmdAliases = (Map) parsedResult.get(KEY_ALIAS_MAPPINGS);
            if (!isValidAliasMap(configUserCmdAliases)) {
            	clearUserAliases();
            	logError(MESSAGE_INVALID_ALIAS_MAP, "");
            }
            
            configSkin = (String) parsedResult.get(KEY_SKIN);
            if (!isValidSkin(configSkin)) {
            	resetSkin();
            	logError(MESSAGE_INVALID_SKIN, configSkin);
            }
            
            writeBack();
        } catch (Exception e) {
        	Log.log("Fail to read user settings", this.getClass());
        	resetAll();
        }
    }

}
```
###### src\common\ConfigurationInterface.java
``` java
package common;

public interface ConfigurationInterface {
	
	/*
	 * @return the default storage location, which cannot be changed
	 */
	public String getDefaultUsrFileDirectory();
	
	/*
	 * @return the current storage location specified by user
	 */
    public String getUsrFileDirectory();
    
    /*
     * @return the current default start time
     */
    public Time getDefaultStartTime();
    
    /*
     * @return the current default end time
     */
    public Time getDefaultEndTime();
    
    /*
     * @return the current theme selected by user
     */
    public String getSkin();
    
    /*
     * Check whether this string is an alias specified by user
     */
    public boolean isUserAlias(String alias);
    
    /*
     * Get the keyword that this string represents
     */
    public String getUserAliasTargetName(String alias);
    
    /*
     * After the storage file moved a new location, set configuration 
     * to remember this new location
     */
    public void setStorageLocation(String newDir);
    
    /*
     * Record a new default start time specified by user
     */
    public void setDefaultStartTime(String newTime);
    
    /*
     * Record a new default end time specified by user
     */
    public void setDefaultEndTime(String newTime);
    
    /*
     * Record a new theme specified by user
     */
    public void setSkin(String skin);
    
    /*
     * Set a new alias specified by user
     */
    public void setUserAlias(String alias, String target);
    
    /*
     * Delete an alias previously added by user
     */
    public void removeUserAlias(String alias);
    
    /*
     * Remove all alias previously added by user
     */
    public void clearUserAliases();
    
    /*
     * Record the storage location is set to default
     */
    public void resetStorageLocation();
	
}
```
###### src\common\Time.java
``` java
package common;

public class Time {
	private final int VALID_LENGTH = 5;
	private final int VALID_FIELD_NUM = 2;
	
	private final int INDEX_HOUR = 0;
	private final int INDEX_MIN = 1;
	
	private final int UPPER_BOUND_HOUR = 23;
	private final int UPPER_BOUND_MIN = 59;
	private final int LOWER_BOUND_HOUR = 0;
	private final int LOWER_BOUND_MIN = 0;
	
	private int m_hour;
	private int m_min;
	
	private boolean m_isValid;
	
	public Time(String t) {
		m_isValid = parseValue(t);
	}
	
	public int getHour() {
		return m_hour;
	}
	
	public int getMin() {
		return m_min;
	}
	
	public boolean isValid() {
		 return m_isValid;
	}
	
	private boolean parseValue(String t) {
		String[] ts;
		String hour, min;
		
		if(t == null || t.length() != VALID_LENGTH) {
			return false;
		}
		
		ts = t.split(":");
		
		if(ts.length != VALID_FIELD_NUM) {
			return false;
		}
		
		hour = ts[INDEX_HOUR];
		min = ts[INDEX_MIN];
		
		return parseHour(hour) && parseMin(min);
	}
	
	private boolean parseHour(String s) {
		try {
			m_hour = Integer.parseInt(s);
			return LOWER_BOUND_HOUR <= m_hour && m_hour <= UPPER_BOUND_HOUR;
		} catch(NumberFormatException e){
			return false;
	    }
	}
	
	public boolean parseMin(String s) {
		try {
			m_min = Integer.parseInt(s);
			return LOWER_BOUND_MIN <= m_min && m_min <= UPPER_BOUND_MIN;
		} catch(NumberFormatException e){
			return false;
	    }
	}
}
```
###### src\common\Utilities.java
``` java
    /**
     * Concatenates two warning string with space in between 
     * 
     * @param w1, w2
     * @return concatenated warning string
     */
    public static final String appendWarningStrings(String w1, String w2) {
    	assert(w2 != null);
        if (w1 == null || w1.trim().equals("")) {
        	return w2;
        } else {
        	return w1 + " " + w2;
        }
    }
}
```
###### src\logic\MoveFileAction.java
``` java
package logic;

import java.nio.file.FileAlreadyExistsException;
import java.nio.file.FileSystemException;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;

import common.Configuration;
import common.ConfigurationInterface;
import common.TasksBag;
import common.Utilities;
import logic.exceptions.LogicException;
import parser.commands.CommandData;
import storage.StorageInterface;

public class MoveFileAction implements Action {

    private static final String USR_MSG_MOVE_ERROR = "Failed to move storage file";
    private static final String USR_MSG_MOVE_OK = "Storage file moved!";
    private static final String USR_MSG_MOVE_ERROR_FILE_EXISTING = "Storage file in %1s already exists";
    private static final String USR_MSG_MOVE_ERROR_INVALID_PATH = "The directory %1s does not exist";
    private static final String USR_MSG_MOVE_ERROR_WRONG_TYPE = "The directory %1s is a file, not folder";
    
    private CommandData cCommand;
    private StorageInterface cStore;
    private TasksBag cBag;
    private Path cPath;
    
    public MoveFileAction(CommandData command, TasksBag bag, StorageInterface stor) {
        cCommand = command;
        cStore = stor;
        cBag = bag;
        cPath = command.getPath();
    }

    @Override
    public CommandFeedback execute() throws LogicException  {
        assert cCommand.getCmdType() == CommandData.Type.MOVE : cCommand.getCmdType();
        CommandFeedback fb;
        ConfigurationInterface config = Configuration.getInstance();
    	
        try {
            cStore.moveFileTo(cPath.toString());
            
            config.setStorageLocation(cPath.toString());
            
            fb = new CommandFeedback(cCommand, cBag, USR_MSG_MOVE_OK);

            return fb;
        } catch (FileAlreadyExistsException e) {
        	String fommatted = Utilities.formatString(USR_MSG_MOVE_ERROR_FILE_EXISTING, cPath.toString());
        	throw new LogicException(fommatted);
        } catch (NoSuchFileException e) {
        	String fommatted = Utilities.formatString(USR_MSG_MOVE_ERROR_INVALID_PATH, cPath.toString());
        	throw new LogicException(fommatted);
        } catch (FileSystemException e) {
        	String fommatted = Utilities.formatString(USR_MSG_MOVE_ERROR_WRONG_TYPE, cPath.toString());
        	throw new LogicException(fommatted);
        } catch (Exception e) {
        	return new CommandFeedback(cCommand, cBag, USR_MSG_MOVE_ERROR);
        }
    }
}
```
###### src\logic\UpdateAction.java
``` java
    private String getWarningString() {
    	if (cUpdateSuccess) {
    		return "";
    	} else {
    		return USR_MSG_UPDATE_WARNING_STORE_FAIL;
    	}
    }
}
```
###### src\storage\Database.java
``` java

/*
 * @class: Database
 * 
 * Database is the class implementing the actual file I/O logic, including appending, 
 * insertion, removal, loading of binary data, as well as moving the storage file to 
 * a certain location. Also handles serialization and JSON load parsing. 
 * It keeps a direct and strict map of the content of tasks.json, which is an array
 * of the tasks (in JSON format). 
 */

package storage;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Scanner;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;

class Database {
	// name of storage files
	private final static String FILENAME = "task.txt";
	private final static String TEST_FILENAME = "test_task.txt";
	
	// used to apply singleton pattern
	private static Database _instance;
	
	// IO tools
	private File db;
	private Scanner dbReader;
	private Writer dbWriter;

	// Data persisted by this class
	private List<TaskJson> dbData;
	private HashMap<Integer, TaskJson> dbIndex;
	
	/* 
	 * Use Singleton Pattern, make constructor private and define 
	 * a public method to get the only instance;
	 */
	private Database() {
		
	}
	
	static Database getDatabase() {
		if (_instance == null) {
			_instance = new Database();
    	}
    	
    	return _instance;
	}
	
	/*
	 * Connect to the file named 'tasks.json' in the specified path
	 * @returns true if connect successfully, otherwise false
	 */
	boolean connect (String path, boolean isTestMode) {
		try {
			if (isTestMode) {
				db = new File(path, TEST_FILENAME);
				db.createNewFile();
			} else {
				// look for the file named tasks.json in the specified directory, 
				// if not found, it will create this file. 
				db = new File(path, FILENAME);
				if(!db.exists()) {
					db.createNewFile();
				}
			}

			// parse the content in storage file
			load();
			
			return true;
		} catch (IOException e) {
			dbData = new ArrayList<TaskJson>();
			dbIndex = new HashMap<Integer, TaskJson>();
			return false;
		}
	}
	
	/*
	 * Reset itself to initial status
	 */
	void disconnect () {
		db = null;
		dbData = null;
		dbIndex = null;
	}
	
	/*
	 * Get all persisted tasks 
	 */
	List<TaskJson> selectAll () {
		checkConnected();
		return new ArrayList<TaskJson>(dbData);
	}
	
	/*
	 * Get a certain task specified by its serial number
	 */
	TaskJson selectById (int id) {
		checkConnected();
		return dbIndex.get(id);
	}
	
	/*
	 * Write a new task into storage file
	 * @return the generated id for the new task
	 */
	int insert (TaskJson cj) throws IOException {
		checkConnected();
		
		int last = getLastId();
		int newId = last + 1;
		
		cj.setId(newId);
		dbData.add(cj);
		dbIndex.put(newId, cj);
		save ();
		
		return newId;
	}
	
	/*
	 * Update the attributes of task existing in storage file
	 */
	void update (TaskJson cj) throws IOException {
		checkConnected();
		
		TaskJson cjInDb = dbIndex.get(cj.getId());
		
		cjInDb.update(cj);
		save ();
	}
	
	/*
	 * Delete a task specified by serial number from storage file
	 */
	void delete (int id) throws IOException {
		checkConnected();
		
		TaskJson cj= dbIndex.get(id);
		
		dbData.remove(cj);
		dbIndex.remove(id);
		save ();
	}
	
	/*
	 * Re-add a task which has been deleted
	 */
	void restore (TaskJson cj) throws IOException {
		checkConnected();
		
		dbData.add(cj);
		dbIndex.put(cj.getId(), cj);
		// keep the task in dbData are sorted by their serial numbers
		orderById();
		save ();
	}
	
	/*
	 * Move a storage file to new location
	 * Exceptions are intended to be thrown and be caught by logic
	 */
	void moveTo(String destination, boolean isTestMode) throws IOException {
		checkConnected();
		
		String fileName = isTestMode ? TEST_FILENAME : FILENAME;
		File newDb = new File(destination, fileName);
		
		Files.move(db.toPath(), newDb.toPath());		
		db = newDb;
	}
		
	
	// Private Methods
	
	/*
	 * Read from storage file and parse the content from text to JSON data
	 */
	private void load () throws IOException {
		assert(db != null);
		
		// Read content in storage file
		String plainText = "";
		
		dbReader = new Scanner(db);
		dbReader.useDelimiter("\\Z");
		
		if (dbReader.hasNext()) {
			plainText = dbReader.next();
		}
		
		dbReader.close();
		dbReader = null;
		
		// Parse the content and translate it into a list of tasks
		JSONArray parsedResult = (JSONArray)JSONValue.parse(plainText);
		
		if (parsedResult == null) {
			parsedResult = new JSONArray();
		}
					
		dbData = new ArrayList<TaskJson>();
		dbIndex = new HashMap<Integer, TaskJson>();
		
		addToData(parsedResult);
		save();
	}
	
	// Write the data persisted by this class into the storage file
	private void save () throws IOException {
		checkConnected();
	
		String text = JSONValue.toJSONString(dbData);
		dbWriter = new BufferedWriter(new FileWriter(db));
		
		dbWriter.write(text);
		dbWriter.close();
		dbWriter = null;
	}
	
	// Sort the current data by their serial number
	private void orderById () {
		checkConnected();
		Collections.sort(dbData, TaskJson.getComparator());
	}
	
	private void checkConnected() {
		assert(dbData != null);
		assert(dbIndex != null);
	}
	
	// Find the serial number of the last task in current data
	private int getLastId() {
		checkConnected();
		
		int last; 
		int dbSize = dbData.size();

		if (dbSize < 1) {
			last = 0;
		} else {
			last = Integer.parseInt(dbData.get(dbSize - 1).get("ID"));
		}
		
		return last;
	}
	
	// Add a list of JSON object to currently persisted data
	private void addToData(JSONArray jsons) {
		checkConnected();
		
		for (int i = 0; i < jsons.size(); i ++) {
			JSONObject json = (JSONObject)jsons.get(i);
			TaskJson cj = new TaskJson(json);
			
			if(cj.isValid()) {
				dbData.add(cj);
				dbIndex.put(Integer.parseInt(cj.get("ID")), cj);
			}
		}
	}
}
```
###### src\storage\Storage.java
``` java

/*
 * @class: Storage
 * 
 * The controller of this package. When Storage is invoked by the Logic Component,
 * it controls Database on how to operate the storage file and the persist data.
 */

package storage;

import java.io.IOException;
import java.util.List;

import common.*;

public class Storage implements StorageInterface {
	
	// Data used to apply Singleton Pattern
	private static Storage _instance;
	private static boolean _isTestMode;
	
	// Other class used in this class
	private ConfigurationInterface _config;
	private Database _database;
	
	/* 
	 * Use Singleton Pattern, make constructor private and define 
	 * a public method to get the only instance;
	 */
    private Storage() {
    	
    }
    
    public static Storage getStorage() {
    	if (_instance == null) {
    		_instance = new Storage();
    	}
    	
    	return _instance;
    }

    // Public Methods
    
    /*
     * @see storage.StorageInterface#init()
     */
    @Override
    public void init() {
        Log.log("Storage Init");
        getConfig();
        connectToDatabase();
        Log.log("Storage Init complete");
    }

    /*
     * @see storage.StorageInterface#close()
     */
    @Override
    public void close() {
    	assert(_database != null);
    
        _database.disconnect();
        Log.log("Storage closed");
    }

    /*
     * @see storage.StorageInterface#save(common.Task)
     */
    @Override
    public boolean save(Task c) {
    	assert(_database != null);
    	
        TaskJson cj = new TaskJson(c);
        int id = c.getId();
        
        // Based on the input Task, decide which method of Databse to call
        try {
        	if (id <= 0) {
        		// insert new task if the input has no id
                id = _database.insert(cj);
                c.setId(id);
            } else if (existsInDatabase(id)) {
            	_database.update(cj);
            } else {
            	// if input Task has an id but not exists in Database, meaning
            	// it has been deleted, then restore it
            	_database.restore(cj);
            }
        } catch (IOException e) {
        	return false;
        }
        
        return true;
    }

    /*
     * @see storage.StorageInterface#load(common.TasksBag)
     */
    @Override
    public boolean load(TasksBag c) {
    	assert(_database != null);
    	
        List<TaskJson> data = _database.selectAll();
        for (int i = 0; i < data.size(); i++) {
            c.addTask(data.get(i).toTask());
        }
        
        return true;
    }

    /*
     * @see storage.StorageInterface#delete(common.Task)
     */
    @Override
    public boolean delete(Task c) {
    	assert(_database != null);
    	
    	try {
    		_database.delete(c.getId());
    	} catch (IOException e) {
        	return false;
        }
        
        return true;
    }
    
    /*
     * @see storage.StorageInterface#moveFileTo(java.lang.String)
     */
    @Override
    public void moveFileTo(String destination) throws IOException {
    	assert(_database != null);
    	
    	_database.moveTo(destination, _isTestMode);
    }
    
    // End of Public Methods
    
    
    // Private Methods
    
    /*
     * Connect to the storage file
     */
    private void connectToDatabase() {     
    	assert(_config != null);
    	boolean connectSuccess;
    	
    	_database = Database.getDatabase();
        connectSuccess = tryConnect();
        
        // if the first attempt to connect fails, reset the storage file
        // to default location and re-connect
        if (!connectSuccess) {
        	Log.log("Fail to connect to storage file");
        	_config.resetStorageLocation();
        	tryConnect();
        }    	
    }

    /*
     * Attempt to connect to the database
     * @return true if found or created, otherwise false
     */
    private boolean tryConnect() {
    	assert(_config != null && _database != null);
    	
        String fileLoc = _config.getUsrFileDirectory();
        return _database.connect(fileLoc, _isTestMode);
    }
    
    /*
     * Initialize configuration
     */
    private void getConfig() {
    	_config = Configuration.getInstance();
    }
    
    /*
     * Check whether the task with the input ID exists in database
     */
    private boolean existsInDatabase(int id) {
    	assert( _database != null);
    	
    	return _database.selectById(id) != null;
    }
   
    // End of Private Methods
       
    
    /*
     * Test Methods
     * ( Methods below are only used for Storage unit tests )
     */
    void openTestMode() {
    	_isTestMode = true;
    }
    
    void closeTestMode() {
    	_isTestMode = false;
    }
}
```
###### src\storage\StorageTest.java
``` java
package storage;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.FileSystemException;
import java.nio.file.NoSuchFileException;
import java.util.Calendar;
import java.util.Date;
import java.util.Scanner;

import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import common.Configuration;
import common.ConfigurationInterface;
import common.Task;
import common.TasksBag;

public class StorageTest {
    private final static String TEST_FILENAME = "test_task.txt";

    // Test content to be written into storage file
    private final String TESTFILE_CONTENT_EMPTY = "";
    private final String TESTFILE_CONTENT_INVALID_JSON = "[invalid json)";
    private final String TESTFILE_CONTENT_INVALID_JSON_ARRAY = "\"foo\":\"bar\"";
    private final String TESTFILE_CONTENT_INITIAL = "[]";

    private final String VALID_TASK = "{\"ID\":\"1\","
            + "\"NAME\":\"test valid task\",\"DATE_START\":\"null\",\"DATE_END\":\"null\","
            + "\"IS_COMPLETED\":\"false\"}";

    private final String VALID_TASK_2 = "{\"ID\":\"2\","
            + "\"NAME\":\"test valid task 2\",\"DATE_START\":\"null\",\"DATE_END\":\"null\","
            + "\"IS_COMPLETED\":\"false\"}";

    private final String INVALID_TASK_NO_ID = "{ "
            + "\"NAME\":\"test invalid task\",\"DATE_START\":\"null\",\"DATE_END\":\"null\","
            + "\"IS_COMPLETED\":\"false\" }";

    private final String INVALID_TASK_INVALID_ID_1 = "{ \"ID\": \"0\","
            + "\"NAME\":\"test invalid task\",\"DATE_START\":\"null\",\"DATE_END\":\"null\","
            + "\"IS_COMPLETED\":\"false\" }";

    private final String INVALID_TASK_INVALID_ID_2 = "{ \"ID\": \"-1\","
            + "\"NAME\":\"test invalid task\",\"DATE_START\":\"null\",\"DATE_END\":\"null\","
            + "\"IS_COMPLETED\":\"false\" }";

    private final String INVALID_TASK_INVALID_ID_3 = "{ \"ID\": \"1.5\","
            + "\"NAME\":\"test invalid task\",\"DATE_START\":\"null\",\"DATE_END\":\"null\","
            + "\"IS_COMPLETED\":\"false\" }";

    private final String INVALID_TASK_INVALID_ID_4 = "{ \"ID\": \"bla\","
            + "\"NAME\":\"test invalid task\",\"DATE_START\":\"null\",\"DATE_END\":\"null\","
            + "\"IS_COMPLETED\":\"false\" }";

    private final String INVALID_TASK_NO_NAME = "{ \"ID\": \"2\"," + "\"DATE_START\":\"null\",\"DATE_END\":\"null\","
            + "\"IS_COMPLETED\":\"false\" }";

    private final String INVALID_TASK_INVALID_NAME_1 = "{ \"ID\": \"2\","
            + "\"NAME\":\"\",\"DATE_START\":\"null\",\"DATE_END\":\"null\"," + "\"IS_COMPLETED\":\"false\" }";

    private final String INVALID_TASK_NO_START_DATE = "{ \"ID\": \"2\","
            + "\"NAME\":\"test invalid task\",\"DATE_END\":\"null\"," + "\"IS_COMPLETED\":\"false\" }";

    private final String INVALID_TASK_NO_END_DATE = "{ \"ID\": \"2\","
            + "\"NAME\":\"test invalid task\",\"DATE_START\":\"null\"," + "\"IS_COMPLETED\":\"false\" }";

    private final String INVALID_TASK_INVALID_DATE_1 = "{ \"ID\": \"2\","
            + "\"NAME\":\"test invalid task\",\"DATE_START\":\"bla\",\"DATE_END\":\"null\","
            + "\"IS_COMPLETED\":\"false\" }";

    private final String INVALID_TASK_INVALID_DATE_2 = "{ \"ID\": \"2\","
            + "\"NAME\":\"test invalid task\",\"DATE_START\":\"null\",\"DATE_END\":\"bla\","
            + "\"IS_COMPLETED\":\"false\" }";

    private final String INVALID_TASK_INVALID_DATE_3 = "{ \"ID\": \"2\","
            + "\"NAME\":\"test invalid task\",\"DATE_START\":\"2015-11-06 08:00\","
            + "\"DATE_END\":\"2014-11-06 08:00\"," + "\"IS_COMPLETED\":\"false\" }";

    private final String INVALID_TASK_NO_IS_COMPLETE = "{ \"ID\": \"2\","
            + "\"NAME\":\"test invalid task\",\"DATE_START\":\"null\",\"DATE_END\":\"null\"" + "}";

    private final String INVALID_TASK_INVALID_IS_COMPLETE = "{ \"ID\": \"2\","
            + "\"NAME\":\"test invalid task\",\"DATE_START\":\"null\",\"DATE_END\":\"null\","
            + "\"IS_COMPLETED\":\"bla\" }";

    private final String[] INVALID_TASKS = { INVALID_TASK_NO_ID, INVALID_TASK_INVALID_ID_1, INVALID_TASK_INVALID_ID_2,
            INVALID_TASK_INVALID_ID_3, INVALID_TASK_INVALID_ID_4, INVALID_TASK_NO_NAME, INVALID_TASK_INVALID_NAME_1,
            INVALID_TASK_NO_START_DATE, INVALID_TASK_NO_END_DATE, INVALID_TASK_INVALID_DATE_1,
            INVALID_TASK_INVALID_DATE_2, INVALID_TASK_INVALID_DATE_3, INVALID_TASK_NO_IS_COMPLETE,
            INVALID_TASK_INVALID_IS_COMPLETE };

    // Some path strings used in tests
    private final static String NOT_EXSITS_FILEPATH = "notExists";
    private final static String MOVE_TO_FILEPATH = "newPath";

    private ConfigurationInterface config;
    private String defaultPath;
    private File defaultFile;
    private Storage storage;

    @Before
    public void openTestMode() throws IOException {
        config = Configuration.getInstance();
        defaultPath = config.getDefaultUsrFileDirectory();
        defaultFile = new File(defaultPath, TEST_FILENAME);

        resetDefaultPath();
        createFileIfNotExists(defaultFile);
        writeToFile(defaultFile, TESTFILE_CONTENT_INITIAL);

        storage = Storage.getStorage();
        storage.openTestMode();
    }

    @After
    public void closeTestMode() {
        storage.closeTestMode();
        storage.close();
    }

    @Test
    /*
     * Test if the recorded storage file path does not exist Expected: storage
     * file path reset to default (stored in Configuration), re-create storage
     * file
     */
    public void testInvalidPath() throws IOException {
        File path = new File(NOT_EXSITS_FILEPATH);

        config.setStorageLocation(NOT_EXSITS_FILEPATH);
        Assert.assertEquals(config.getUsrFileDirectory(), NOT_EXSITS_FILEPATH);

        deleteIfExists(path);

        // check the default file in default location does not exist,
        // in order to make sure it is 're-created' below
        deleteIfExists(defaultFile);

        storage = Storage.getStorage();
        storage.init();

        Assert.assertEquals(config.getUsrFileDirectory(), defaultPath);

        assertFileExists(defaultFile);
    }

    @Test
    /*
     * Test if path exists but the storage file does not exist Expected:
     * re-create the storage file
     */
    public void testStorageFileNotExists() throws IOException {
        // check the default file in default location does not exist,
        // in order to make sure it is 're-created' below
        deleteIfExists(defaultFile);

        storage = Storage.getStorage();
        storage.init();

        // check the file in default path has been re-created
        assertFileExists(defaultFile);
    }

    @Test
    /*
     * Test if file exists but the content is empty Expected: file is
     * initialized to an empty JSON array
     */
    public void testLoadEmpty() throws IOException {
        testInvalidLoad(TESTFILE_CONTENT_EMPTY);
    }

    @Test
    /*
     * Test if file exists but the content is not in valid JSON format Expected:
     * file is initialized to an empty JSON array
     */
    public void testLoadInvalidJSON() throws IOException {
        testInvalidLoad(TESTFILE_CONTENT_INVALID_JSON);
    }

    @Test
    /*
     * Test if file content is in JSON format but not an array Expected: file is
     * initialized to an empty JSON array
     */
    public void testLoadInvalidJSONArray() throws IOException {
        testInvalidLoad(TESTFILE_CONTENT_INVALID_JSON_ARRAY);
    }

    @Test
    /*
     * Test if file content is JSON Array but some entries cannot be parsed to
     * tasks Expected: those entries failed to be parsed are discarded, without
     * affecting others
     */
    public void testLoadInvalidTasks() throws IOException {
        TasksBag tb;
        String fileContent;

        for (int i = 0; i < INVALID_TASKS.length; i++) {
            writeToFile(defaultFile, "[" + VALID_TASK + INVALID_TASKS[i] + "]");

            storage.init();

            tb = new TasksBag();
            storage.load(tb);
            Assert.assertEquals(1, tb.size());

            fileContent = readFile(defaultFile);
            Assert.assertEquals(fileContent, "[" + VALID_TASK + "]");
            storage.close();
        }
    }

    @Test
    /*
     * Test if file content is valid Expected: load successfully
     */
    public void testLoadValidTasks() throws IOException {
        TasksBag tb;

        writeToFile(defaultFile, "[" + VALID_TASK + VALID_TASK_2 + "]");

        storage.init();

        tb = new TasksBag();
        storage.load(tb);
        Assert.assertEquals(2, tb.size());
        storage.close();
    }

    @Test
    /*
     * Test if save a new task Expected: load the saved task
     */
    public void testSaveNew() throws IOException {
        TasksBag tb;
        Task task = new Task("test", createDate(2015, 10, 10, 0, 0, 0), createDate(2015, 11, 11, 0, 0, 0));
        Task outTask;
        storage.init();

        tb = new TasksBag();
        storage.load(tb);
        Assert.assertEquals(tb.size(), 0);

        boolean result = storage.save(task);
        Assert.assertTrue(result);

        tb = new TasksBag();
        storage.load(tb);
        Assert.assertEquals(tb.size(), 1);

        outTask = tb.getTask(0);
        assertTaskIdentical(task, outTask);
    }

    @Test
    /*
     * Test if save a new task Expected: load the saved task
     */
    public void testSaveUpdate() throws IOException {
        Task task = new Task("test", createDate(2015, 10, 10, 0, 0, 0), createDate(2015, 11, 11, 0, 0, 0));
        storage.init();

        testSaved(task, 0);

        task.setName("haha");
        testSaved(task, 0);

        task.setStart(createDate(2015, 5, 10, 0, 0, 0));
        testSaved(task, 0);

        task.setEnd(createDate(2016, 5, 10, 1, 0, 0));
        testSaved(task, 0);

        task.setComplete(true);
        ;
        testSaved(task, 0);
    }

    @Test
    /*
     * Test if delete a task Expected: task gets removed from the storage file
     */
    public void testDelete() throws IOException {
        TasksBag tb;
        Task task = new Task("test", createDate(2015, 10, 10, 0, 0, 0), createDate(2015, 11, 11, 0, 0, 0));
        storage.init();
        storage.save(task);

        tb = new TasksBag();
        storage.load(tb);
        Assert.assertEquals(tb.size(), 1);

        storage.delete(task);
        tb = new TasksBag();
        storage.load(tb);
        Assert.assertEquals(tb.size(), 0);
    }

    @Test
    /*
     * Test if delete a task Expected: task gets removed from the storage file
     */
    public void testRestore() throws IOException {
        TasksBag tb;
        Task task = new Task("test", createDate(2015, 10, 10, 0, 0, 0), createDate(2015, 11, 11, 0, 0, 0));
        Task outTask;
        storage.init();
        storage.save(task);

        tb = new TasksBag();
        storage.load(tb);
        Assert.assertEquals(tb.size(), 1);

        storage.delete(task);
        tb = new TasksBag();
        storage.load(tb);
        Assert.assertEquals(tb.size(), 0);

        storage.save(task);
        tb = new TasksBag();
        storage.load(tb);
        Assert.assertEquals(tb.size(), 1);
        outTask = tb.getTask(0);
        assertTaskIdentical(task, outTask);
    }

    @Test
    /*
     * Test if move storage file Expected: file successfully moved to a new
     * directory
     */
    public void testMoveSuccess() throws IOException {
        TasksBag tb;
        Task task = new Task("test", createDate(2015, 10, 10, 0, 0, 0), createDate(2015, 11, 11, 0, 0, 0));
        Task outTask;
        File newPath = new File(MOVE_TO_FILEPATH);
        File newFile = new File(MOVE_TO_FILEPATH, TEST_FILENAME);

        storage.init();
        storage.save(task);

        createFolderIfNotExists(newPath);
        deleteIfExists(newFile);

        storage.moveFileTo(MOVE_TO_FILEPATH);
        assertFileExists(newFile);

        tb = new TasksBag();
        storage.load(tb);
        Assert.assertEquals(tb.size(), 1);

        outTask = tb.getTask(0);
        assertTaskIdentical(task, outTask);
        storage.close();
        deleteIfExists(newPath);
    }

    @Test
    /*
     * Test if move storage file to a location which is not a folder Expected:
     * throw an exception indicating
     */
    public void testMoveFailNotFolder() throws IOException {
        File newPath = new File(MOVE_TO_FILEPATH);
        File newFile = new File(MOVE_TO_FILEPATH, TEST_FILENAME);

        createFileIfNotExists(newPath);
        deleteIfExists(newFile);

        storage.init();

        try {
            storage.moveFileTo(MOVE_TO_FILEPATH);
            Assert.fail("A FileSystemException should have been thrown");
        } catch (FileSystemException e) {
            return;
        } catch (Exception e) {
            Assert.fail(
                    String.format("A FileSystemException should have been thrown, but get %s", e.getClass().getName()));
        }
    }

    @Test
    /*
     * Test if move storage file to a location which is not a folder Expected:
     * throw an exception indicating
     */
    public void testMoveFailNoDir() throws IOException {
        File newPath = new File(MOVE_TO_FILEPATH);

        deleteIfExists(newPath);

        storage.init();

        try {
            storage.moveFileTo(MOVE_TO_FILEPATH);
            Assert.fail("A NoSuchFileException should have been thrown");
        } catch (NoSuchFileException e) {
            return;
        } catch (Exception e) {
            Assert.fail(
                    String.format("A NoSuchFileException should have been thrown, but get %s", e.getClass().getName()));
        }
    }

    @Test
    /*
     * Test if move storage file to a location which is not a folder Expected:
     * throw an exception indicating
     */
    public void testMoveFailAlreadyExists() throws IOException {
        File newPath = new File(MOVE_TO_FILEPATH);
        File newFile = new File(MOVE_TO_FILEPATH, TEST_FILENAME);

        createFolderIfNotExists(newPath);
        createFileIfNotExists(newFile);

        storage.init();

        try {
            storage.moveFileTo(MOVE_TO_FILEPATH);
            Assert.fail("A FileAlreadyExistsException should have been thrown");
        } catch (FileAlreadyExistsException e) {
            return;
        } catch (Exception e) {
            Assert.fail(String.format("A FileAlreadyExistsException should have been thrown, but get %s",
                    e.getClass().getName()));
        }
    }

    @Test
    /*
     * Test for a entire flow of a use case
     */
    public void testComplicatedCases() {
        TasksBag tb;
        Storage storage = Storage.getStorage();
        
        Task c1 = new Task("storage test1",
        		           createDate(2015, 10, 10, 0, 0, 0), 
        		           createDate(2015, 11, 11, 0, 0, 0));
        Task c2 = new Task("storage test2", 
        		           createDate(2016, 10, 10, 0, 0, 0), 
        		           createDate(2016, 11, 11, 0, 0, 0));
        Task c3 = new Task("storage test3", 
        		           createDate(2017, 10, 10, 0, 0, 0), 
        		           createDate(2017, 11, 11, 0, 0, 0));

        storage.init();
        storage.save(c1);
        storage.save(c2);
        storage.save(c3);

        tb = new TasksBag();
        storage.load(tb);
        Assert.assertEquals(tb.size(), 3);

        c1.setName("new");
        storage.save(c1);

        tb = new TasksBag();
        storage.load(tb);

        Task ct = tb.getTask(0);
        String ctName = ct.getName();
        Assert.assertEquals("new", ctName);

        storage.delete(c2);

        tb = new TasksBag();
        storage.load(tb);
        Assert.assertEquals(tb.size(), 2);
    }
    

    // Private Methods
    /*
     * Test if file exists but the content is corrupted, input could be empty,
     * invalid JSON format or invalid Task format
     */
    private void testInvalidLoad(String content) throws IOException {
        TasksBag tb;
        String fileContent;

        writeToFile(defaultFile, content);

        storage.init();

        tb = new TasksBag();
        storage.load(tb);
        Assert.assertEquals(0, tb.size());

        fileContent = readFile(defaultFile);
        Assert.assertEquals(fileContent, TESTFILE_CONTENT_INITIAL);
    }

    private void testSaved(Task task, int index) throws IOException {
        TasksBag tb = new TasksBag();
        Task outTask;

        storage.save(task);
        storage.load(tb);

        outTask = tb.getTask(index);
        assertTaskIdentical(task, outTask);
    }

    private void writeToFile(File f, String content) throws IOException {
        Writer writer = new BufferedWriter(new FileWriter(f));
        String fileContent;

        writer.write(content);
        writer.close();

        fileContent = readFile(f);
        Assert.assertEquals(fileContent, content);
    }

    private String readFile(File f) throws FileNotFoundException {
        String content = "";
        Scanner scanner = new Scanner(f);
        scanner.useDelimiter("\\Z");

        if (scanner.hasNext()) {
            content = scanner.next();
        }

        scanner.close();

        return content;
    }
    
    /*
     * Create date object for testing
     */
    private Date createDate(int year, int month, int day, int hour, int minute, int second) {
        Calendar calender = Calendar.getInstance();
        calender.set(year, month, day, hour, minute, second);
        return new Date(calender.getTimeInMillis());
    }

    private void resetDefaultPath() throws IOException {
        String currentConfigPath;
        String defaultPath = config.getDefaultUsrFileDirectory();

        config.resetStorageLocation();

        currentConfigPath = config.getUsrFileDirectory();
        Assert.assertEquals(currentConfigPath, defaultPath);
    }

    private void deleteIfExists(File f) {
        if (!f.exists()) {
            return;
        }

        if (f.isDirectory()) {
            deleteFolder(f);
        } else {
            deleteFile(f);
        }

        Assert.assertFalse(f.exists());
    }

    private void deleteFile(File f) {
        f.delete();
    }

    private void deleteFolder(File f) {
        String[] children = f.list();
        for (int i = 0; i < children.length; i++) {
            new File(f, children[i]).delete();
        }

        f.delete();
    }

    private void createFileIfNotExists(File f) throws IOException {
        if (!f.exists()) {
            f.createNewFile();
        }

        assertFileExists(f);
    }

    private void createFolderIfNotExists(File f) throws IOException {
        f.delete();

        if (f.exists() && !f.isDirectory()) {
            f.delete();
        }

        if (!f.exists()) {
            f.mkdir();
        }

        assertFileExists(f);
    }

    private void assertFileExists(File f) {
        Assert.assertTrue(f.exists());
    }

    // Check whether two tasks's attributes are all the same
    private void assertTaskIdentical(Task task1, Task task2) {
        Assert.assertEquals(task1.getId(), task2.getId());
        Assert.assertEquals(task1.getName(), task2.getName());
        Assert.assertEquals(task1.isCompleted(), task2.isCompleted());

        assertDateEqual(task1.getStart(), task2.getStart());
        assertDateEqual(task1.getEnd(), task2.getEnd());
    }

    private void assertDateEqual(Date d1, Date d2) {
        int result = d1.compareTo(d2);
        Assert.assertEquals(result, 1);
    }
}
```
###### src\storage\TaskJson.java
``` java

/*
 * @class: TaskJson
 * 
 * A subclass of JSONObject which specifically represents a task in Celebi. 
 * It is designed for the translation between JSON object and the Task class. 
 * It has the same fields as the Task class, but in the key-value pair format.
 */

package storage;

import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Comparator;
import java.util.Date;
import java.util.LinkedHashMap;

import org.json.simple.JSONObject;

import common.*;

class TaskJson extends LinkedHashMap<String, String>{
	private static final long serialVersionUID = 1L;
	
	// All keys for a task
	static final String KEY_NAME_ID = "ID";
	static final String KEY_NAME_NAME = "NAME";
	static final String KEY_NAME_DATE_START = "DATE_START";
	static final String KEY_NAME_DATE_END = "DATE_END";
	static final String KEY_NAME_IS_COMPLETED = "IS_COMPLETED";
	static final String[] KEYS = { 
		KEY_NAME_ID, KEY_NAME_NAME, KEY_NAME_DATE_START, 
		KEY_NAME_DATE_END, KEY_NAME_IS_COMPLETED 
	};
	
	// Some special values used in this class
	static final String VALUE_NULL = "null";
	static final String VALUE_TRUE = "true";
	static final String VALUE_FALSE = "false";
	
	// Tools to parse date from string
	static final String DATE_FOTMAT = "yyyy-MM-dd HH:mm";
	static SimpleDateFormat formatter = new SimpleDateFormat(DATE_FOTMAT);
	
	boolean _isValid = true;
	
	// Two constructors, one is from Task class, the other is from JSON object
	TaskJson (Task c) {
		String id = Integer.toString(c.getId());
		String name = c.getName();
		String start = formatDate(c.getStart());
		String end = formatDate(c.getEnd());
		String isCompleted = c.isCompleted() ? VALUE_TRUE : VALUE_FALSE;
		
		put(KEY_NAME_ID, id);
		put(KEY_NAME_NAME, name);
		put(KEY_NAME_DATE_START, start);
		put(KEY_NAME_DATE_END, end);
		put(KEY_NAME_IS_COMPLETED, isCompleted);
	}
	
	TaskJson (JSONObject j) {
		mapFromJSONObject(j);
				
		// It is possible for the content in storage file being corrupted,
		// therefore validation is needed in this case
		if (isValid()) {
			validateId ();
			validateName ();
			validateDates ();
			validateIsCompleted ();
		}
	}
	
	// Transfer itself into a Task object
	Task toTask () {
		int id = Integer.parseInt(get(KEY_NAME_ID));
		String name = get(KEY_NAME_NAME);
		Date start = parseDate(get(KEY_NAME_DATE_START));
		Date end = parseDate(get(KEY_NAME_DATE_END));
		boolean isCompleted = get(KEY_NAME_IS_COMPLETED).equals(VALUE_TRUE);
		
		Task c = new Task(name, start, end);
		c.setId(id);
		c.setComplete(isCompleted);
		
		return c;
	}
	
	// Getters
	boolean isValid () {
		return _isValid;
	}
	
	int getId () {
		String id = get(KEY_NAME_ID);
		if (id == null) {
			return 0;
		} else {
			return Integer.parseInt(get(KEY_NAME_ID));
		}
	}
	
	// Setters
	void setId (int id) {
		put(KEY_NAME_ID, Integer.toString(id));
	}

	void update (TaskJson cj) {
		// make all its attributes the same as the input TaskJson
		put(KEY_NAME_ID, cj.get(KEY_NAME_ID));
		put(KEY_NAME_NAME, cj.get(KEY_NAME_NAME));
		put(KEY_NAME_DATE_START, cj.get(KEY_NAME_DATE_START));
		put(KEY_NAME_DATE_END, cj.get(KEY_NAME_DATE_END));
		put(KEY_NAME_IS_COMPLETED, cj.get(KEY_NAME_IS_COMPLETED));
	}
	
	// Private Methods
	private String formatDate (Date d) {
		if (d == null) {
			return VALUE_NULL;
		}
		return formatter.format(d);
	}
	
	private Date parseDate (String s) {
		ParsePosition pos = new ParsePosition(0);
		return formatter.parse(s, pos); 
	}
	
	private void mapFromJSONObject(JSONObject j) {
		for (int i = 0; i < KEYS.length; i++) {
			checkAndMapField(j, KEYS[i]);
		}
	}
	
	private void checkAndMapField (JSONObject j, String key) {
		if (j.get(key) == null) {
			_isValid = false;
		} else {
			put(key, (String)j.get(key));
		}
	}
	
	// Validators
	private void validateId () {
		try {
			int id = Integer.parseInt(get(KEY_NAME_ID));
			if (id < 1) {
				_isValid = false;
			}
		} catch (NumberFormatException e) {
			_isValid = false;
		}
	}
	
	private void validateName () {
		if (get(KEY_NAME_NAME).trim().equals("")) {
			_isValid = false;
		}
	}
	
	private void validateDates () {
		Date parsedStart = parseDate(get(KEY_NAME_DATE_START));
		Date parsedEnd = parseDate(get(KEY_NAME_DATE_END));
		
		if (!get(KEY_NAME_DATE_START).equals("null") && parsedStart == null) {
			_isValid = false;
		} else if (!get(KEY_NAME_DATE_END).equals("null") && parsedEnd == null) {
			_isValid = false;
		} else if (parsedStart != null && parsedEnd != null && parsedStart.compareTo(parsedEnd) > 0) {
			_isValid = false;
		}		
	}
	
	private void validateIsCompleted () {
		if (!get(KEY_NAME_IS_COMPLETED).equals(VALUE_TRUE) && 
			!get(KEY_NAME_IS_COMPLETED).equals(VALUE_FALSE)) {
			_isValid = false;
		}
	}
	
	// End of Private Methods
	
	// An inner class specially designed to compare two tasks
	static class TJComparator implements Comparator<TaskJson> {
		@Override
		public int compare(TaskJson tj1, TaskJson tj2) {
			int id1 = tj1.getId();
			int id2 = tj2.getId();
			
			assert(id1 > 0 && id2 > 0);
			
			if (id1 < id2) {
				return -1;
			} else if (id1 == id2) {
				return 0;
			} else {
				return 1;
			}
		}
	}
	
	static TJComparator getComparator () {
		return new TJComparator();
	}
}
```
